[
  {
    "id": "1",
    "question": "Which annotation denotes a Spring Boot application?",
    "options": [
      "@Configuration",
      "@Component",
      "@SpringBootApplication",
      "@Service"
    ],
    "answer": "@SpringBootApplication",
    "type": "MCQ",
    "difficulty": "Easy",
    "isObjective": true,
    "explanation": {
      "intro": "Explanation: Which annotation denotes a Spring Boot application?",
      "points": [
        "Correct answer: @SpringBootApplication.",
        "Key concept to remember related to the question."
      ]
    },
    "askedBy": [
      "interview",
      "practice"
    ],
    "technology": "Spring Boot"
  },
  {
    "id": "2",
    "question": "Default embedded server in Spring Boot is?",
    "options": [
      "Tomcat",
      "Jetty",
      "Undertow",
      "GlassFish"
    ],
    "answer": "Tomcat",
    "type": "MCQ",
    "difficulty": "Easy",
    "isObjective": true,
    "explanation": {
      "intro": "Explanation: Default embedded server in Spring Boot is?",
      "points": [
        "Correct answer: Tomcat.",
        "Key concept to remember related to the question."
      ]
    },
    "askedBy": [
      "interview",
      "practice"
    ],
    "technology": "Spring Boot"
  },
  {
    "id": "3",
    "question": "Which annotation is used to inject a bean by type?",
    "options": [
      "@Inject",
      "@Autowired",
      "@Resource",
      "@Value"
    ],
    "answer": "@Autowired",
    "type": "MCQ",
    "difficulty": "Easy",
    "isObjective": true,
    "explanation": {
      "intro": "Explanation: Which annotation is used to inject a bean by type?",
      "points": [
        "Correct answer: @Autowired.",
        "Key concept to remember related to the question."
      ]
    },
    "askedBy": [
      "interview",
      "practice"
    ],
    "technology": "Spring Boot"
  },
  {
    "id": "4",
    "question": "What does @RestController combine?",
    "options": [
      "@Controller + @ResponseBody",
      "@Controller + @Service",
      "@Component + @Bean",
      "@Service + @Repository"
    ],
    "answer": "@Controller + @ResponseBody",
    "type": "MCQ",
    "difficulty": "Medium",
    "isObjective": true,
    "explanation": {
      "intro": "Explanation: What does @RestController combine?",
      "points": [
        "Correct answer: @Controller + @ResponseBody.",
        "Key concept to remember related to the question."
      ]
    },
    "askedBy": [
      "interview",
      "practice"
    ],
    "technology": "Spring Boot"
  },
  {
    "id": "5",
    "question": "Which property file is used by Spring Boot by default?",
    "options": [
      "application.yml",
      "application.properties",
      "settings.xml",
      "config.json"
    ],
    "answer": "application.properties",
    "type": "MCQ",
    "difficulty": "Easy",
    "isObjective": true,
    "explanation": {
      "intro": "Explanation: Which property file is used by Spring Boot by default?",
      "points": [
        "Correct answer: application.properties.",
        "Key concept to remember related to the question."
      ]
    },
    "askedBy": [
      "interview",
      "practice"
    ],
    "technology": "Spring Boot"
  },
  {
    "id": "6",
    "question": "Explain Spring Dependency Injection and its benefits.",
    "options": [],
    "answer": "DI injects dependencies rather than creating them; benefits include loose coupling, easier testing, and separation of concerns.",
    "type": "Interview",
    "difficulty": "Medium",
    "isObjective": false,
    "explanation": {
      "intro": "Dependency Injection (DI) in Spring is a design pattern where the container (Spring IoC container) is responsible for creating and injecting dependencies into objects instead of objects creating their own dependencies. It decouples object creation from business logic, making applications more modular and testable.",
      "points": [
          "\n\n### Types of DI in Spring:",
          "\n         1. **Constructor Injection** – Dependencies are provided through the constructor.",
          "\n         2. **Setter Injection** – Dependencies are set via setter methods.",
          "\n         3. **Field Injection** – Dependencies are injected directly into fields using annotations like `@Autowired`.",
          "\n\n### Benefits of DI:\n",
          "           - **Loose coupling**: Reduces dependency between classes.",
          "\n         - **Easier testing**: Mock dependencies can be injected during unit testing.",
          "\n         - **Improved maintainability**: Changing a dependency does not require modifying dependent classes.",
          "\n         - **Better modularization**: Promotes cleaner and reusable code."
      ],
      "language": "java",
      "code": "import org.springframework.stereotype.Component;\nimport org.springframework.beans.factory.annotation.Autowired;\n\n@Component\nclass Engine {}\n\n@Component\nclass Car {\n    private final Engine engine;\n\n    @Autowired\n    public Car(Engine engine) { // Constructor Injection\n        this.engine = engine;\n    }\n}\n\n// Here, Spring automatically injects an `Engine` object into the `Car` object."
    },
    "askedBy": [
      "interview"
    ],
    "technology": "Spring Boot"
  },
  {
    "id": "7",
    "question": "How does Spring Boot auto-configuration work?",
    "options": [],
    "answer": "Auto-configuration uses classpath and beans to apply sensible defaults; can be customized or disabled; @EnableAutoConfiguration triggers it.",
    "type": "Interview",
    "difficulty": "Hard",
    "isObjective": false,
    "explanation": {
      "intro": "Spring Boot auto-configuration automatically sets up Spring application components based on the libraries in the classpath and configurations provided, reducing the need for manual XML or Java config.",
      "points": [
        "**Trigger**: Enabled via `@EnableAutoConfiguration` (included in `@SpringBootApplication`).",
        "**Discovery**: Uses `SpringFactoriesLoader` to load configuration classes listed in `META-INF/spring.factories`.",
        "**Conditions**: Auto-config classes are guarded by `@Conditional` annotations (e.g., `@ConditionalOnClass`, `@ConditionalOnMissingBean`).",
        "**Customization**: Developers can override defaults using `application.properties` or by defining beans manually.",
        "**Example**: With `spring-boot-starter-data-jpa` in the classpath, Spring Boot configures a `DataSource`, `EntityManagerFactory`, and `TransactionManager` automatically."
      ],
      "language": "java",
      "code": "import org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication  // includes @EnableAutoConfiguration\npublic class MyApp {\n    public static void main(String[] args) {\n        SpringApplication.run(MyApp.class, args);\n    }\n}\n",
      "diagram": "/diagrams/spring/spring_boot_auto_config.md"
    },
    "askedBy": [
      "interview"
    ],
    "technology": "Spring Boot"
  },
  {
    "id": "8",
    "question": "Describe transaction propagation behaviors in Spring.",
    "options": [],
    "answer": "Propagation settings like REQUIRED, REQUIRES_NEW, SUPPORTS affect transactional boundary joining or creation; important for nested calls.",
    "type": "Interview",
    "difficulty": "Hard",
    "isObjective": false,
    "explanation": {
      "intro": "Transaction propagation in Spring defines how methods with transactional boundaries interact when called within existing transactions. It controls whether a new transaction is created, joined, or executed without one.",
      "points": [
        "**REQUIRED (default)**: Joins current transaction if exists, else creates a new one.",
        "**REQUIRES_NEW**: Always starts a new transaction, suspends existing one.",
        "**SUPPORTS**: Joins current transaction if exists, else runs non-transactionally.",
        "**NOT_SUPPORTED**: Runs without a transaction, suspends if one exists.",
        "**MANDATORY**: Must run within an existing transaction, else throws exception.",
        "**NEVER**: Must not run within a transaction, throws exception if one exists.",
        "**NESTED**: Creates a nested transaction using savepoints (dependent on database support)."
      ],
      "language": "java",
      "code": "import org.springframework.transaction.annotation.Propagation;\nimport org.springframework.transaction.annotation.Transactional;\n\npublic class PaymentService {\n\n    @Transactional(propagation = Propagation.REQUIRED)\n    public void processPayment() {\n        // joins existing or creates new transaction\n    }\n\n    @Transactional(propagation = Propagation.REQUIRES_NEW)\n    public void logTransaction() {\n        // always starts a new transaction\n    }\n}\n",
      "diagram": "/diagrams/spring/spring_txn_propagation.md"
    },
    "askedBy": [
      "interview"
    ],
    "technology": "Spring Boot"
  },
  {
    "id": "9",
    "question": "Which statement about Spring Boot Actuator is correct?",
    "options": [
      "It is used only for logging purposes in a Spring Boot application.",
      "It provides production-ready features like monitoring, metrics, and health checks.",
      "It is a replacement for Spring Boot Starter dependencies.",
      "It is required for building REST controllers in Spring Boot."
    ],
    "answer": "It provides production-ready features like monitoring, metrics, and health checks.",
    "type": "MCQ",
    "difficulty": "Easy",
    "isObjective": true,
    "explanation": {
      "intro": "Spring Boot Actuator adds several production-ready features to help you monitor and manage applications.",
      "points": [
        "Actuator exposes endpoints (e.g., /actuator/health, /actuator/metrics) to monitor application state.",
        "It provides integration with external monitoring systems like Prometheus, Micrometer, etc.",
        "It does not replace Spring Boot starters; rather, it enhances observability and monitoring."
      ]
    },
    "askedBy": [
      "interview",
      "quiz"
    ],
    "technology": "Spring Boot"
  },
  {
    "id": "10",
    "question": "Which annotation/keyword is used for Auto-configuration in Spring Boot?",
    "options": [
      "@EnableAutoConfiguration",
      "@SpringBootApplication",
      "@Configuration",
      "@ComponentScan"
    ],
    "answer": "@EnableAutoConfiguration",
    "type": "MCQ",
    "difficulty": "Easy",
    "isObjective": true,
    "explanation": {
      "intro": "Spring Boot auto-configuration automatically configures your application based on the dependencies present in the classpath.",
      "points": [
        "@EnableAutoConfiguration is the core annotation that tells Spring Boot to enable auto-configuration.",
        "@SpringBootApplication is a meta-annotation that combines @EnableAutoConfiguration, @Configuration, and @ComponentScan.",
        "@Configuration and @ComponentScan are important for defining beans and scanning components, but they do not enable auto-configuration on their own."
      ]
    },
    "askedBy": [
      "interview",
      "quiz"
    ],
    "technology": "Spring Boot"
  },
  {
    "id": "11",
    "question": "Describe the pros and cons of Auto-configuration in Spring Boot.",
    "options": [],
    "answer": "Spring Boot Auto-configuration simplifies application setup by configuring beans automatically based on classpath and dependencies, but it may also add hidden complexity and unnecessary components if not managed properly.",
    "type": "Interview",
    "difficulty": "Medium",
    "isObjective": false,
    "explanation": {
      "intro": "Spring Boot Auto-configuration is a core feature that reduces boilerplate setup by configuring beans automatically depending on the libraries present. It has both advantages and disadvantages.",
      "points": [
        "Pros:",
        "- Reduces boilerplate configuration and speeds up development.",
        "- Provides sensible defaults for most use cases.",
        "- Improves developer productivity by handling common setup automatically.",
        "- Easy to override defaults with custom configurations.",
        "Cons:",
        "- Can introduce hidden complexity, making it harder to understand the exact setup.",
        "- May create unnecessary beans or configurations not required for the application.",
        "- Debugging issues may be difficult if you are unaware of which auto-configuration classes are applied.",
        "- Less control in some cases compared to fully manual configuration."
      ]
    },
    "askedBy": [
      "interview",
      "quiz",
      "theory"
    ],
    "technology": "Spring Boot"
  },
  {
    "id": "12",
    "question": "Which statement about Controllers is correct?",
    "options": [
      "Controllers in Spring Boot are annotated with @Controller or @RestController and handle incoming web requests.",
      "Controllers are used only to manage database transactions.",
      "Controllers are required for auto-configuration in Spring Boot.",
      "Controllers are used only for defining application properties."
    ],
    "answer": "Controllers in Spring Boot are annotated with @Controller or @RestController and handle incoming web requests.",
    "type": "MCQ",
    "difficulty": "Easy",
    "isObjective": true,
    "explanation": {
      "intro": "In Spring MVC and Spring Boot, controllers are responsible for handling incoming HTTP requests and returning responses.",
      "points": [
        "@Controller is used for returning views (like JSP/Thymeleaf templates).",
        "@RestController is a specialization of @Controller that returns JSON or XML directly as response body.",
        "They define request mappings using annotations like @RequestMapping, @GetMapping, @PostMapping.",
        "Controllers are part of the MVC (Model-View-Controller) design pattern and are not related to auto-configuration or database management."
      ]
    },
    "askedBy": [
      "interview",
      "quiz"
    ],
    "technology": "Spring Boot"
  },
  {
    "id": "13",
    "question": "How would you design/implement Controllers in a production system?",
    "options": [],
    "answer": "In a production system, Controllers should be lightweight, focus only on handling HTTP requests, delegate business logic to Service classes, and follow best practices such as proper request/response mapping, exception handling, validation, and security integration.",
    "type": "Interview",
    "difficulty": "Hard",
    "isObjective": false,
    "explanation": {
      "intro": "Controllers in a production system should be designed with clean separation of concerns, maintainability, and scalability in mind. They should not hold business logic but instead act as entry points to the application.",
      "points": [
        "Structure & Annotations:",
        "- Use @RestController or @Controller depending on API type (REST vs MVC view).",
        "- Use @RequestMapping, @GetMapping, @PostMapping, etc., for clear endpoint definitions.",
        
        "Separation of Concerns:",
        "- Keep Controllers thin — delegate heavy logic to Service and Repository layers.",
        "- Maintain clear boundaries between layers (Controller → Service → Repository).",
        
        "Request/Response Handling:",
        "- Use DTOs (Data Transfer Objects) to avoid exposing entities directly.",
        "- Validate input using @Valid and javax.validation annotations.",
        "- Return consistent response structures (e.g., ResponseEntity with proper status codes).",
        
        "Error & Exception Handling:",
        "- Implement centralized exception handling using @ControllerAdvice.",
        "- Provide meaningful error messages with proper HTTP status codes.",
        
        "Security & Performance:",
        "- Integrate with Spring Security for authentication/authorization.",
        "- Avoid exposing sensitive data in responses.",
        "- Consider pagination for large datasets and caching where applicable.",
        
        "Maintainability & Documentation:",
        "- Follow REST best practices for endpoint naming (nouns, plural).",
        "- Document APIs with Swagger/OpenAPI for clarity.",
        "- Write unit and integration tests for Controllers."
      ]
    },
    "askedBy": [
      "interview",
      "system-design"
    ],
    "technology": "Spring Boot"
  },
  {
    "id": "14",
    "question": "Which annotation/keyword is used for enabling Actuator in Spring Boot?",
    "options": [
      "No specific annotation is required; adding the dependency enables Actuator automatically.",
      "@EnableActuator",
      "@EnableAutoConfiguration",
      "@SpringBootApplication"
    ],
    "answer": "No specific annotation is required; adding the dependency enables Actuator automatically.",
    "type": "MCQ",
    "difficulty": "Easy",
    "isObjective": true,
    "explanation": {
      "intro": "Spring Boot Actuator does not require any special annotation to be enabled.",
      "points": [
        "Adding the dependency `spring-boot-starter-actuator` automatically activates Actuator features.",
        "Actuator endpoints (like /actuator/health, /actuator/info) are auto-configured through Spring Boot’s auto-configuration mechanism.",
        "Configuration (like enabling/disabling endpoints) is managed via `application.properties` or `application.yml`.",
        "Unlike other features, Actuator does not require a custom annotation such as @EnableActuator."
      ]
    },
    "askedBy": [
      "interview",
      "quiz"
    ],
    "technology": "Spring Boot"
  },
  {
    "id": "15",
    "question": "Describe the pros and cons of using Spring Boot Actuator.",
    "options": [],
    "answer": "Spring Boot Actuator provides production-ready features like health checks, metrics, and monitoring, making applications easier to manage, but it can introduce security risks and overhead if not configured properly.",
    "type": "Interview",
    "difficulty": "Medium",
    "isObjective": false,
    "explanation": {
      "intro": "Spring Boot Actuator helps developers and operators monitor and manage applications in production environments. While powerful, it also has some drawbacks if not handled carefully.",
      "points": [
        "Pros:",
        "- Provides ready-to-use endpoints for health checks, metrics, and environment details.",
        "- Simplifies integration with monitoring tools like Prometheus, Grafana, and Micrometer.",
        "- Helps detect issues early by exposing runtime application insights.",
        "- Reduces development effort for building custom monitoring solutions.",
        "- Supports customizable endpoints and security configurations.",
        "Cons:",
        "- Exposes sensitive application details if endpoints are not secured properly.",
        "- May add slight performance overhead due to continuous monitoring and metrics collection.",
        "- Can increase application complexity if too many endpoints are enabled unnecessarily.",
        "- Requires careful configuration for production (e.g., restricting access, endpoint filtering)."
      ]
    },
    "askedBy": [
      "interview",
      "quiz",
      "theory"
    ],
    "technology": "Spring Boot"
  },
  {
    "id": "16",
    "question": "Which command is used to enable Spring Boot Actuator?",
    "options": [
      "No specific command; adding the dependency spring-boot-starter-actuator enables it automatically.",
      "mvn spring-boot:run --enable-actuator",
      "spring run app.groovy --actuator",
      "gradle bootRun --actuator"
    ],
    "answer": "No specific command; adding the dependency spring-boot-starter-actuator enables it automatically.",
    "type": "MCQ",
    "difficulty": "Easy",
    "isObjective": true,
    "explanation": {
      "intro": "Spring Boot Actuator does not require a special command to run.",
      "points": [
        "Actuator is enabled automatically by including the dependency `spring-boot-starter-actuator` in your project.",
        "Once enabled, you can access endpoints like `/actuator/health`, `/actuator/info`, etc.",
        "Actuator configuration is managed via `application.properties` or `application.yml`.",
        "There is no command-line flag like `--actuator` to enable it."
      ]
    },
    "askedBy": [
      "interview",
      "quiz"
    ],
    "technology": "Spring Boot"
  },
  {
    "id": "17",
    "question": "What is the default behavior of Data JPA?",
    "options": [
      "It only provides manual query execution through JPQL.",
      "It automatically implements repository interfaces, derives queries from method names, and manages transactions.",
      "It requires explicit implementation of all repository methods.",
      "It disables transactions by default to improve performance."
    ],
    "answer": "It automatically implements repository interfaces, derives queries from method names, and manages transactions.",
    "type": "MCQ",
    "difficulty": "Medium",
    "isObjective": true,
    "explanation": {
      "intro": "Spring Data JPA provides a lot of behavior out-of-the-box without requiring boilerplate code.",
      "points": [
        "Automatically generates repository implementations at runtime.",
        "Derives queries from method names (e.g., findByEmail).",
        "Manages transactions automatically using @Transactional.",
        "Uses JPA/Hibernate defaults for entity mapping.",
        "Lazy loads associations unless marked as EAGER.",
        "Supports pagination and sorting with Pageable and Sort."
      ]
    },
    "askedBy": [
      "interview",
      "quiz"
    ],
    "technology": "Spring Data JPA"
  },
  {
    "id": "18",
    "question": "Describe pros and cons of Data JPA.",
    "options": [],
    "answer": "Spring Data JPA reduces boilerplate code, provides derived queries, CRUD support, and transaction management, but it also introduces abstraction overhead, performance pitfalls, and limited flexibility for complex queries.",
    "type": "Interview",
    "difficulty": "Medium",
    "isObjective": false,
    "explanation": {
      "intro": "Spring Data JPA has both advantages and disadvantages that developers should consider when designing production systems.",
      "pros": [
        "Reduces boilerplate code by eliminating manual DAO implementations.",
        "Supports derived queries based on method names.",
        "Provides built-in CRUD, pagination, and sorting through JpaRepository.",
        "Integrated with Spring's transaction management (@Transactional).",
        "Seamlessly integrates with Hibernate and other JPA providers.",
        "Allows custom queries using JPQL, native SQL, and @Query annotation.",
        "Speeds up prototyping and development."
      ],
      "cons": [
        "Adds abstraction overhead, hiding actual SQL execution.",
        "Derived queries are limited for complex business logic.",
        "Can lead to performance issues like LazyInitializationException or N+1 queries.",
        "Tightly coupled with JPA/Hibernate, making vendor switching harder.",
        "Requires deep understanding of JPA concepts (entity states, caching, transactions).",
        "Auto-generated queries may not be optimal for high-performance needs.",
        "Entity graphs can consume significant memory in large-scale apps."
      ]
    },
    "askedBy": [
      "interview",
      "quiz"
    ],
    "technology": "Spring Data JPA"
  },
  {
    "id": "19",
    "question": "Describe pros and cons of Controllers.",
    "options": [],
    "answer": "Controllers in Spring simplify request handling, enforce separation of concerns, and support REST APIs, but they can become bloated, tightly coupled, and harder to test if not designed properly.",
    "type": "Interview",
    "difficulty": "Medium",
    "isObjective": false,
    "explanation": {
      "intro": "Controllers in Spring MVC/Boot manage the web layer by handling HTTP requests and delegating business logic to services.",
      "pros": [
        "Provides clear separation of web, business, and persistence layers.",
        "Simplifies HTTP request mapping with annotations.",
        "Supports RESTful APIs with @RestController.",
        "Easy integration with validation and exception handling.",
        "Encourages delegation to service classes for maintainability."
      ],
      "cons": [
        "Controllers may become bloated if overloaded with business logic.",
        "Mixing responsibilities can lead to tight coupling and poor design.",
        "Heavy request handling logic may degrade performance.",
        "Testing requires mocking HTTP layer or using Spring testing utilities.",
        "Learning curve around annotations and request lifecycle.",
        "Scalability issues if controllers are not modularized properly."
      ]
    },
    "askedBy": [
      "interview",
      "quiz"
    ],
    "technology": "Spring Boot"
  },
  {
    "id": "20",
    "question": "Which annotation is used to define Controllers in Spring?",
    "options": [
      "@Service",
      "@Repository",
      "@Controller / @RestController",
      "@ComponentScan"
    ],
    "answer": "@Controller / @RestController",
    "type": "MCQ",
    "difficulty": "Easy",
    "isObjective": true,
    "explanation": {
      "intro": "Controllers in Spring Boot are defined using specific annotations that mark a class as part of the web layer.",
      "points": [
        "@Controller is used to mark a class as a Spring MVC controller that returns views.",
        "@RestController is a convenience annotation that combines @Controller and @ResponseBody to build RESTful APIs.",
        "@Service and @Repository are used for business and persistence layers, not for controllers.",
        "@ComponentScan is used for scanning components but does not define controllers."
      ]
    },
    "askedBy": [
      "interview",
      "quiz"
    ],
    "technology": "Spring Boot"
  },
  {
    "id": "21",
    "question": "Explain how Controllers work in Spring Boot.",
    "options": [],
    "answer": "In Spring Boot, Controllers handle incoming HTTP requests, delegate business logic to services, and return responses as views or JSON/XML objects.",
    "type": "Interview",
    "difficulty": "Medium",
    "isObjective": false,
    "explanation": {
      "intro": "Controllers in Spring Boot are part of the web layer and use annotations to map HTTP requests to handler methods.",
      "points": [
        "Controllers are annotated with @Controller (for web views) or @RestController (for REST APIs).",
        "Methods inside controllers are mapped to URLs using @RequestMapping, @GetMapping, @PostMapping, etc.",
        "When an HTTP request is received, Spring DispatcherServlet routes it to the matching controller method.",
        "Controllers validate input, call service layer methods for business logic, and return data or views.",
        "@RestController automatically serializes Java objects into JSON or XML responses using HttpMessageConverters.",
        "Exception handling can be centralized with @ControllerAdvice."
      ]
    },
    "askedBy": [
      "interview",
      "quiz"
    ],
    "technology": "Spring Boot"
  },
  {
    "id": "22",
    "question": "Which annotation/keyword is used for Transactions?",
    "options": [
      "@Service",
      "@Transactional",
      "@Repository",
      "@Component"
    ],
    "answer": "@Transactional",
    "type": "MCQ",
    "difficulty": "Easy",
    "isObjective": true,
    "explanation": {
      "intro": "Spring provides the @Transactional annotation to manage database transactions declaratively.",
      "points": [
        "@Transactional can be applied at class or method level.",
        "It ensures that a method executes within a transaction context.",
        "If an exception occurs, the transaction is rolled back automatically (by default for runtime exceptions).",
        "It reduces boilerplate code compared to programmatic transaction management.",
        "It works with various transaction managers such as DataSourceTransactionManager or JpaTransactionManager."
      ]
    },
    "askedBy": [
      "interview",
      "quiz"
    ],
    "technology": "Spring Framework"
  },
  {
    "id": "23",
    "question": "How would you design/implement Transactions in a production system?",
    "options": [],
    "answer": "Design transactions declaratively using @Transactional at the service layer, keep transactions short, choose appropriate propagation and isolation, handle retries and idempotency for failures, and adopt distributed transaction patterns (sagas or compensating actions) when crossing service boundaries.",
    "type": "Interview",
    "difficulty": "Hard",
    "isObjective": false,
    "explanation": {
      "intro": "Production-grade transaction design focuses on correctness, performance, maintainability, and the ability to recover from failures. Prefer declarative transaction management, define clear boundaries, and choose appropriate strategies for local vs distributed transactions.",
      "points": [
        "Placement & Boundary:",
        "- Apply @Transactional on Service-layer methods (business boundary), not on Controllers or repositories directly.",
        "- Keep transaction scope minimal — start late and commit/rollback early to reduce locking and contention.",
        "",
        "Declarative Transaction Management:",
        "- Use @Transactional (Spring) for declarative behavior; avoids boilerplate programmatic transaction code.",
        "- Configure attributes: propagation, isolation, readOnly, timeout, and rollbackFor/ noRollbackFor.",
        "- Remember @Transactional works on public methods and self-invocation bypasses proxying (use AOP-aware patterns or call through proxy).",
        "",
        "Propagation & Isolation:",
        "- Choose propagation: REQUIRED (default) for typical flows, REQUIRES_NEW to start independent transactions when needed, SUPPORTS/NEVER/NOT_SUPPORTED for specific cases.",
        "- Select isolation level based on consistency needs (READ_COMMITTED, REPEATABLE_READ, SERIALIZABLE) while weighing performance and locking implications.",
        "",
        "Error Handling & Rollback:",
        "- Configure rollback rules explicitly when you need rollback on checked exceptions (rollbackFor).",
        "- Fail fast and throw meaningful exceptions; log transaction boundaries for troubleshooting.",
        "",
        "Performance & Resource Management:",
        "- Keep transactions short to avoid long-held DB locks and connection exhaustion.",
        "- Use connection pooling and set sensible timeouts.",
        "- Avoid heavy computation or remote calls inside transactions; if needed, move those out or use separate transactions.",
        "",
        "Concurrency Control:",
        "- Use optimistic locking (version columns) for high-concurrency updates to avoid blocking.",
        "- Use pessimistic locks only when necessary and for short durations.",
        "",
        "Distributed Transactions & Microservices:",
        "- Prefer eventual consistency and Saga patterns (choreography or orchestration) instead of 2PC in microservices.",
        "- Use compensating transactions for rollback-like behavior across services.",
        "- If strict distributed ACID is required, consider a transaction coordinator (2PC) but be aware of complexity and scalability tradeoffs.",
        "",
        "Idempotency & Retries:",
        "- Design idempotent operations or use idempotency keys for retry-safe endpoints.",
        "- Implement retry with backoff for transient failures and ensure retries do not violate business invariants.",
        "",
        "Testing & Observability:",
        "- Write unit tests for transaction boundaries and integration tests that verify commit/rollback behavior.",
        "- Monitor transaction metrics (duration, rollback rate) and profile slow transactions.",
        "- Use logs and distributed tracing to track transaction flow across services.",
        "",
        "Security & Schema Considerations:",
        "- Ensure appropriate DB user privileges and auditing for transactional operations.",
        "- Avoid large transactional batches; if processing many rows, use chunked/batched operations with smaller transactions.",
        "",
        "Operational Best Practices:",
        "- Document transaction design decisions and default settings (timeouts, isolation).",
        "- Provide runbooks for transaction-related incidents (deadlocks, long-running transactions)."
      ]
    },
    "askedBy": [
      "interview",
      "system-design"
    ],
    "technology": "Spring Framework / Databases"
  },
  {
    "id": "24",
    "question": "What is the purpose of Profiles in Spring Boot?",
    "options": [
      "To manage different logging levels for various environments",
      "To define and group beans/configurations for different environments (e.g., dev, test, prod)",
      "To automatically enable Actuator endpoints",
      "To configure caching for production systems"
    ],
    "answer": "To define and group beans/configurations for different environments (e.g., dev, test, prod)",
    "type": "MCQ",
    "difficulty": "Easy",
    "isObjective": true,
    "explanation": {
      "intro": "Spring Boot Profiles allow developers to separate configurations for different environments, making applications flexible and environment-aware.",
      "points": [
        "Profiles let you group beans, properties, and configurations for specific environments like dev, test, staging, and prod.",
        "You can activate profiles using application-{profile}.properties or application.yml files.",
        "Profiles can be enabled via the 'spring.profiles.active' property in configuration or command-line arguments.",
        "Helps avoid hardcoding environment-specific values and simplifies deployment.",
        "Supports multiple profiles simultaneously (e.g., dev + debug)."
      ]
    },
    "askedBy": [
      "interview",
      "quiz"
    ],
    "technology": "Spring Boot"
  },
  {
    "id": "25",
    "question": "Describe pros and cons of Profiles in Spring Boot.",
    "options": [],
    "answer": "Spring Boot Profiles allow separation of configurations for different environments, improving maintainability and flexibility, but can add complexity if overused or mismanaged.",
    "type": "Interview",
    "difficulty": "Medium",
    "isObjective": false,
    "explanation": {
      "intro": "Spring Boot Profiles provide a way to manage environment-specific configurations and beans in a clean and organized manner.",
      "pros": [
        "Separates configuration for different environments (dev, test, prod).",
        "Improves maintainability by avoiding hardcoded values.",
        "Supports environment-specific beans and properties.",
        "Can activate multiple profiles simultaneously for flexibility.",
        "Simplifies deployment and testing across environments."
      ],
      "cons": [
        "Overuse of profiles can make configuration complex and hard to track.",
        "Misconfigured profiles may cause runtime errors if the wrong profile is active.",
        "Testing with multiple profiles requires careful management.",
        "May introduce confusion if multiple overlapping profiles define the same beans or properties."
      ]
    },
    "askedBy": [
      "interview",
      "quiz"
    ],
    "technology": "Spring Boot"
  },
  {
    "id": "26",
    "question": "What is the default behavior of AOP in Spring?",
    "options": [
      "Spring AOP applies aspects only to methods in beans managed by the Spring container.",
      "Spring AOP automatically applies aspects to all classes, including those not managed by Spring.",
      "Spring AOP replaces all method implementations with aspect logic.",
      "Spring AOP requires explicit XML configuration for every method to apply aspects."
    ],
    "answer": "Spring AOP applies aspects only to methods in beans managed by the Spring container.",
    "type": "MCQ",
    "difficulty": "Medium",
    "isObjective": true,
    "explanation": {
      "intro": "Spring AOP provides declarative aspect-oriented programming features, but by default it only works on Spring-managed beans.",
      "points": [
        "Aspects are applied via proxies created by the Spring container.",
        "Only beans managed by Spring are eligible for advice execution.",
        "You can define advice types like @Before, @After, @Around, etc.",
        "By default, Spring AOP is proxy-based and does not modify the target class bytecode directly.",
        "For non-Spring-managed objects or more advanced weaving, AspectJ full weaving is required."
      ]
    },
    "askedBy": [
      "interview",
      "quiz"
    ],
    "technology": "Spring AOP"
  },
  {
    "id": "27",
    "question": "How would you design/implement AOP in a production system?",
    "options": [],
    "answer": "Design AOP in production by defining cross-cutting concerns such as logging, security, or transactions as aspects, using pointcuts to target Spring-managed beans, keeping aspects focused and maintainable, and monitoring performance impacts.",
    "type": "Interview",
    "difficulty": "Hard",
    "isObjective": false,
    "explanation": {
      "intro": "Aspect-Oriented Programming (AOP) helps separate cross-cutting concerns from business logic, improving maintainability and modularity in production systems.",
      "points": [
        "Identify Cross-Cutting Concerns:",
        "- Common examples: logging, metrics, security, transactions, caching, exception handling.",
        "- Keep aspects focused on a single responsibility to avoid complexity.",
        "",
        "Define Aspects & Advice:",
        "- Use @Aspect annotation to define an aspect class.",
        "- Use advice annotations like @Before, @After, @Around, @AfterReturning, and @AfterThrowing.",
        "- Avoid heavy processing inside advice to reduce performance impact.",
        "",
        "Pointcut Design:",
        "- Define precise pointcuts to target only relevant Spring-managed beans and methods.",
        "- Use reusable expressions and named pointcuts to simplify management.",
        "",
        "Separation of Concerns:",
        "- Do not mix business logic with aspects.",
        "- Keep controller/service/repository layers clean and delegate cross-cutting logic to aspects.",
        "",
        "Testing & Observability:",
        "- Write unit tests and integration tests for aspects to ensure advice executes correctly.",
        "- Monitor performance, especially with @Around advice that wraps method execution.",
        "",
        "Performance Considerations:",
        "- Avoid applying aspects to high-frequency methods unless necessary.",
        "- Use lightweight logging frameworks and asynchronous processing if required.",
        "",
        "Security & Compliance:",
        "- Ensure aspects handling security or transactions follow best practices.",
        "- Avoid exposing sensitive data in logging aspects.",
        "",
        "Deployment & Maintainability:",
        "- Document pointcuts and advice clearly for future maintenance.",
        "- Use profiling to detect bottlenecks introduced by aspects.",
        "- Consider using AspectJ (compile-time or load-time weaving) for advanced use cases requiring non-Spring-managed objects.",
        "",
        "Operational Best Practices:",
        "- Keep AOP configuration consistent across environments.",
        "- Monitor logs and metrics generated by aspects for anomalies.",
        "- Avoid overusing AOP; only apply where cross-cutting logic is truly needed."
      ]
    },
    "askedBy": [
      "interview",
      "system-design"
    ],
    "technology": "Spring AOP"
  },
  {
    "id": "28",
    "question": "Which statement about Bean lifecycle is correct?",
    "options": [
      "Spring Beans are instantiated, populated, initialized, and eventually destroyed by the Spring container.",
      "Spring Beans are only instantiated once at compile time and never destroyed.",
      "Spring Beans require manual initialization and destruction for every instance.",
      "Spring Beans cannot have custom initialization or destruction methods."
    ],
    "answer": "Spring Beans are instantiated, populated, initialized, and eventually destroyed by the Spring container.",
    "type": "MCQ",
    "difficulty": "Medium",
    "isObjective": true,
    "explanation": {
      "intro": "The Spring Bean lifecycle defines the sequence of steps from bean instantiation to destruction, managed by the Spring IoC container.",
      "points": [
        "Beans are created (instantiated) by the container either eagerly or lazily depending on scope and configuration.",
        "Dependencies are injected (populated) via constructor, setter, or field injection.",
        "Initialization callbacks occur, either via @PostConstruct, InitializingBean, or custom init-method.",
        "The bean is ready for use within the container.",
        "Destruction callbacks occur for singleton beans during container shutdown, using @PreDestroy, DisposableBean, or custom destroy-method.",
        "Prototype-scoped beans are not destroyed by the container automatically; the client must manage their lifecycle."
      ]
    },
    "askedBy": [
      "interview",
      "quiz"
    ],
    "technology": "Spring Framework"
  },
  {
    "id": "29",
    "question": "Explain how Bean lifecycle works in Spring Boot.",
    "options": [],
    "answer": "In Spring Boot, the Spring container manages the entire lifecycle of beans—from instantiation, dependency injection, initialization, usage, to destruction—allowing developers to plug in custom logic at initialization or destruction points.",
    "type": "Interview",
    "difficulty": "Medium",
    "isObjective": false,
    "explanation": {
      "intro": "Spring Boot leverages the Spring Framework IoC container to manage bean lifecycles automatically, enabling customization and lifecycle callbacks.",
      "points": [
        "Bean Instantiation: Spring container creates bean instances, either eagerly (default for singleton) or lazily (if @Lazy is used).",
        "Dependency Injection: The container injects required dependencies via constructor, setter, or field injection.",
        "Initialization Phase:",
        "- Executes @PostConstruct annotated methods.",
        "- Executes afterPropertiesSet() if the bean implements InitializingBean.",
        "- Executes custom init-method if specified in configuration.",
        "Bean Usage: Bean is ready for use by the application and injected wherever required.",
        "Destruction Phase:",
        "- Executes @PreDestroy annotated methods.",
        "- Executes destroy() if the bean implements DisposableBean.",
        "- Executes custom destroy-method if specified.",
        "- Note: Prototype-scoped beans are not managed for destruction by the container; clients handle it manually.",
        "Spring Boot adds convenience with auto-configuration, so lifecycle management is seamless for most beans, including those created via @Configuration classes."
      ]
    },
    "askedBy": [
      "interview",
      "quiz"
    ],
    "technology": "Spring Boot"
  },
  {
    "id": "30",
    "question": "Which statement about Controllers is correct?",
    "options": [
      "Controllers in Spring handle HTTP requests and return responses.",
      "Controllers in Spring are only responsible for database operations.",
      "Controllers automatically manage transactions for services.",
      "Controllers in Spring are used to configure application properties."
    ],
    "answer": "Controllers in Spring handle HTTP requests and return responses.",
    "type": "MCQ",
    "difficulty": "Easy",
    "isObjective": true,
    "explanation": {
      "intro": "Controllers in Spring MVC or Spring Boot handle web requests and responses, serving as the web layer in the application.",
      "points": [
        "Controllers are annotated with @Controller or @RestController.",
        "They map HTTP requests to handler methods using @RequestMapping, @GetMapping, @PostMapping, etc.",
        "Controllers delegate business logic to service layer beans.",
        "They return views or serialized responses (JSON/XML) to the client.",
        "Controllers do not directly handle database persistence or configuration management."
      ]
    },
    "askedBy": [
      "interview",
      "quiz"
    ],
    "technology": "Spring Boot"
  },
  {
    "id": "31",
    "question": "Explain how Controllers works in Spring Boot.",
    "options": [],
    "answer": "Controllers in Spring Boot handle incoming HTTP requests, delegate business logic to services, and return responses as views or JSON/XML objects.",
    "type": "Interview",
    "difficulty": "Medium",
    "isObjective": false,
    "explanation": {
      "intro": "Controllers in Spring Boot are part of the web layer and use annotations to map HTTP requests to handler methods.",
      "points": [
        "Controllers are annotated with @Controller (for web views) or @RestController (for REST APIs).",
        "Methods inside controllers are mapped to URLs using @RequestMapping, @GetMapping, @PostMapping, etc.",
        "When an HTTP request is received, Spring DispatcherServlet routes it to the matching controller method.",
        "Controllers validate input, call service layer methods for business logic, and return data or views.",
        "@RestController automatically serializes Java objects into JSON or XML responses using HttpMessageConverters.",
        "Exception handling can be centralized with @ControllerAdvice."
      ]
    },
    "askedBy": [
      "interview",
      "quiz"
    ],
    "technology": "Spring Boot"
  },
  {
    "id": "32",
    "question": "What is the default behavior of Dependency Injection in Spring?",
    "options": [
      "Spring performs constructor-based injection only.",
      "Spring performs setter-based injection only.",
      "Spring automatically injects dependencies by type (autowiring) for Spring-managed beans.",
      "Spring requires manual instantiation of all dependent beans."
    ],
    "answer": "Spring automatically injects dependencies by type (autowiring) for Spring-managed beans.",
    "type": "MCQ",
    "difficulty": "Easy",
    "isObjective": true,
    "explanation": {
      "intro": "Spring Dependency Injection (DI) automatically provides required dependencies to Spring-managed beans, simplifying object creation and decoupling components.",
      "points": [
        "Spring supports both constructor-based and setter-based DI.",
        "By default, Spring injects dependencies by type using @Autowired or constructor injection.",
        "The Spring container manages bean lifecycles and injects dependencies automatically.",
        "Qualifiers (@Qualifier) can be used to specify which bean to inject when multiple candidates exist.",
        "DI promotes loose coupling and easier testing of components."
      ]
    },
    "askedBy": [
      "interview",
      "quiz"
    ],
    "technology": "Spring Framework"
  },
  {
    "id": "33",
    "question": "Explain how Dependency Injection works in Spring Boot.",
    "options": [],
    "answer": "In Spring Boot, the Spring container automatically manages the creation and injection of dependencies into Spring-managed beans using constructor, setter, or field injection, promoting loose coupling and easier testing.",
    "type": "Interview",
    "difficulty": "Medium",
    "isObjective": false,
    "explanation": {
      "intro": "Dependency Injection (DI) in Spring Boot allows the framework to provide required dependencies to beans automatically, reducing boilerplate and promoting modular design.",
      "points": [
        "Beans are defined using annotations like @Component, @Service, @Repository, or @Controller.",
        "Dependencies are injected using @Autowired (field, setter, or constructor), or by constructor injection without @Autowired in recent Spring versions.",
        "The Spring container resolves dependencies by type and, if necessary, by qualifier when multiple candidates exist.",
        "Spring Boot auto-configuration simplifies DI by scanning packages for beans automatically.",
        "DI allows swapping implementations easily, supports mocking in tests, and encourages separation of concerns."
      ]
    },
    "askedBy": [
      "interview",
      "quiz"
    ],
    "technology": "Spring Boot"
  },
  {
    "id": "34",
    "question": "Which statement about Bean lifecycle is correct?",
    "options": [
      "Spring Beans are instantiated, dependencies injected, initialized, and eventually destroyed by the Spring container.",
      "Spring Beans are created only once at compile-time and never destroyed.",
      "Spring Beans require manual initialization and destruction for every instance.",
      "Spring Beans cannot have custom initialization or destruction methods."
    ],
    "answer": "Spring Beans are instantiated, dependencies injected, initialized, and eventually destroyed by the Spring container.",
    "type": "MCQ",
    "difficulty": "Medium",
    "isObjective": true,
    "explanation": {
      "intro": "The Spring Bean lifecycle describes how the Spring container manages bean creation, initialization, and destruction.",
      "points": [
        "Beans are created (instantiated) by the container.",
        "Dependencies are injected via constructor, setter, or field injection.",
        "Initialization callbacks occur via @PostConstruct, InitializingBean, or custom init-method.",
        "The bean is ready for use within the application.",
        "Destruction callbacks occur via @PreDestroy, DisposableBean, or custom destroy-method (for singleton beans).",
        "Prototype-scoped beans are not destroyed automatically; clients manage their lifecycle."
      ]
    },
    "askedBy": [
      "interview",
      "quiz"
    ],
    "technology": "Spring Framework"
  },
  {
    "id": "35",
    "question": "How would you design/implement Bean lifecycle in a production system?",
    "options": [],
    "answer": "In production, manage the Spring Bean lifecycle by using appropriate scopes, leveraging initialization and destruction callbacks, minimizing resource usage, and ensuring proper dependency injection and cleanup for singleton and prototype beans.",
    "type": "Interview",
    "difficulty": "Hard",
    "isObjective": false,
    "explanation": {
      "intro": "Proper management of the Bean lifecycle in production ensures efficient resource utilization, predictable behavior, and maintainable code.",
      "points": [
        "Use correct bean scopes: singleton for shared instances, prototype for per-use instances, request/session for web contexts.",
        "Leverage lifecycle callbacks: @PostConstruct, InitializingBean for initialization; @PreDestroy, DisposableBean for cleanup.",
        "Minimize resource-heavy operations in init methods to prevent startup delays.",
        "Ensure dependencies are properly injected and validate bean configuration.",
        "For prototype beans, handle destruction manually to avoid resource leaks.",
        "Use lazy initialization for beans not required at startup to improve application startup time.",
        "Monitor and log bean lifecycle events for troubleshooting in production.",
        "Avoid long-running or blocking operations in bean constructors or lifecycle methods.",
        "Document and maintain clear initialization and destruction order for beans with dependencies."
      ]
    },
    "askedBy": [
      "interview",
      "system-design"
    ],
    "technology": "Spring Framework"
  },
  {
    "id": "36",
    "question": "What is the purpose of Security in Spring Boot?",
    "options": [
      "To manage database transactions automatically",
      "To handle HTTP requests and responses",
      "To provide authentication, authorization, and protection against common security threats",
      "To configure application profiles for different environments"
    ],
    "answer": "To provide authentication, authorization, and protection against common security threats",
    "type": "MCQ",
    "difficulty": "Easy",
    "isObjective": true,
    "explanation": {
      "intro": "Spring Boot Security provides mechanisms to secure applications by managing user authentication, authorization, and protecting against common web vulnerabilities.",
      "points": [
        "Supports authentication using in-memory, JDBC, LDAP, OAuth2, JWT, etc.",
        "Provides role-based and method-level authorization.",
        "Protects against common attacks like CSRF, XSS, and session fixation.",
        "Allows configuration of security rules for specific endpoints or paths.",
        "Integrates with Spring Boot auto-configuration for minimal setup."
      ]
    },
    "askedBy": [
      "interview",
      "quiz"
    ],
    "technology": "Spring Boot Security"
  },
  {
    "id": "37",
    "question": "Describe pros and cons of Security in Spring Boot.",
    "options": [],
    "answer": "Spring Boot Security provides robust authentication and authorization mechanisms and protects applications from common security threats, but it can add complexity, require careful configuration, and may introduce performance overhead if misconfigured.",
    "type": "Interview",
    "difficulty": "Medium",
    "isObjective": false,
    "explanation": {
      "intro": "Spring Boot Security helps secure applications at multiple layers, but implementing and configuring it properly requires careful planning and understanding of security principles.",
      "pros": [
        "Provides built-in authentication and authorization mechanisms.",
        "Protects against common web vulnerabilities like CSRF, XSS, and session fixation.",
        "Easily integrates with OAuth2, JWT, LDAP, and other security providers.",
        "Supports method-level and role-based access control.",
        "Auto-configuration simplifies basic security setup for Spring Boot applications."
      ],
      "cons": [
        "Can increase application complexity and learning curve for developers.",
        "Misconfiguration can leave security vulnerabilities.",
        "May introduce performance overhead if too many security checks or filters are applied.",
        "Customizing security behavior beyond defaults can be challenging.",
        "Requires ongoing maintenance to handle updates and evolving security threats."
      ]
    },
    "askedBy": [
      "interview",
      "quiz"
    ],
    "technology": "Spring Boot Security"
  },
  {
    "id": "38",
    "question": "What is the purpose of Bean lifecycle in Spring Boot?",
    "options": [
      "To manage the creation, initialization, and destruction of beans automatically by the Spring container",
      "To handle HTTP requests and responses in web applications",
      "To provide authentication and authorization for Spring applications",
      "To configure environment-specific properties and profiles"
    ],
    "answer": "To manage the creation, initialization, and destruction of beans automatically by the Spring container",
    "type": "MCQ",
    "difficulty": "Easy",
    "isObjective": true,
    "explanation": {
      "intro": "The Bean lifecycle in Spring Boot defines how the Spring container manages beans from instantiation to destruction.",
      "points": [
        "Beans are instantiated by the Spring container either eagerly or lazily depending on scope.",
        "Dependencies are injected via constructor, setter, or field injection.",
        "Initialization callbacks occur using @PostConstruct, InitializingBean, or custom init-method.",
        "Destruction callbacks occur using @PreDestroy, DisposableBean, or custom destroy-method.",
        "Proper lifecycle management ensures resource efficiency, predictable behavior, and maintainable code."
      ]
    },
    "askedBy": [
      "interview",
      "quiz"
    ],
    "technology": "Spring Boot"
  },
  {
    "id": "39",
    "question": "Explain how Bean lifecycle works in Spring Boot.",
    "options": [],
    "answer": "In Spring Boot, the Spring container manages the lifecycle of beans from instantiation, dependency injection, initialization, usage, to destruction, allowing custom logic at initialization and destruction points.",
    "type": "Interview",
    "difficulty": "Medium",
    "isObjective": false,
    "explanation": {
      "intro": "Spring Boot uses the Spring IoC container to manage bean lifecycles automatically, supporting initialization and destruction callbacks and dependency injection.",
      "points": [
        "Bean Instantiation: Spring container creates bean instances, either eagerly (default for singleton) or lazily (@Lazy).",
        "Dependency Injection: Spring injects required dependencies via constructor, setter, or field injection.",
        "Initialization Phase:",
        "- Executes @PostConstruct methods.",
        "- Executes afterPropertiesSet() if implementing InitializingBean.",
        "- Executes custom init-method if defined.",
        "Bean Usage: Bean is available for injection and use in the application.",
        "Destruction Phase:",
        "- Executes @PreDestroy methods.",
        "- Executes destroy() if implementing DisposableBean.",
        "- Executes custom destroy-method if defined.",
        "- Prototype beans are not destroyed automatically; clients handle their cleanup.",
        "Spring Boot auto-configuration manages most bean lifecycles seamlessly, reducing boilerplate and manual management."
      ]
    },
    "askedBy": [
      "interview",
      "quiz"
    ],
    "technology": "Spring Boot"
  },
  {
    "id": "40",
    "question": "Which command/annotation is used to enable Dependency Injection in Spring?",
    "options": [
      "@Autowired",
      "@Component",
      "@Configuration",
      "@Bean"
    ],
    "answer": "@Autowired",
    "type": "MCQ",
    "difficulty": "Easy",
    "isObjective": true,
    "explanation": {
      "intro": "Spring provides the @Autowired annotation to automatically inject dependencies into Spring-managed beans.",
      "points": [
        "@Autowired can be used on constructors, setter methods, or fields.",
        "Spring resolves the dependency by type and injects the appropriate bean.",
        "For multiple candidate beans, @Qualifier can specify which bean to inject.",
        "Constructor injection is preferred in modern Spring applications for immutability and testability.",
        "@Autowired works only with Spring-managed beans in the application context."
      ]
    },
    "askedBy": [
      "interview",
      "quiz"
    ],
    "technology": "Spring Framework"
  },
  {
    "id": "41",
    "question": "Explain how Dependency Injection works in Spring Boot.",
    "options": [],
    "answer": "In Spring Boot, Dependency Injection (DI) allows the Spring container to automatically provide required dependencies to beans using annotations like @Autowired, constructor, or setter injection, promoting loose coupling and easier testing.",
    "type": "Interview",
    "difficulty": "Medium",
    "isObjective": false,
    "explanation": {
      "intro": "Dependency Injection in Spring Boot allows the framework to manage object creation and wiring, reducing boilerplate code and increasing modularity.",
      "points": [
        "Beans are defined using annotations such as @Component, @Service, @Repository, or @Controller.",
        "Dependencies are injected automatically using @Autowired or constructor injection.",
        "Spring resolves beans by type, and @Qualifier can be used when multiple candidates exist.",
        "Spring Boot auto-configuration scans packages and registers beans automatically for DI.",
        "DI improves testability by allowing easy mocking of dependencies and decouples components."
      ]
    },
    "askedBy": [
      "interview",
      "quiz"
    ],
    "technology": "Spring Boot"
  },
  {
    "id": "42",
    "question": "Which statement about Bean lifecycle is correct?",
    "options": [
      "Spring Beans are instantiated, dependencies injected, initialized, and eventually destroyed by the Spring container.",
      "Spring Beans are created once at compile-time and never destroyed.",
      "Spring Beans require manual initialization and destruction for every instance.",
      "Spring Beans cannot have custom initialization or destruction methods."
    ],
    "answer": "Spring Beans are instantiated, dependencies injected, initialized, and eventually destroyed by the Spring container.",
    "type": "MCQ",
    "difficulty": "Medium",
    "isObjective": true,
    "explanation": {
      "intro": "The Bean lifecycle in Spring describes how the container manages bean creation, dependency injection, initialization, usage, and destruction.",
      "points": [
        "Beans are instantiated by the Spring container.",
        "Dependencies are injected via constructor, setter, or field injection.",
        "Initialization callbacks occur via @PostConstruct, InitializingBean, or custom init-method.",
        "Beans are ready for use after initialization.",
        "Destruction callbacks occur via @PreDestroy, DisposableBean, or custom destroy-method (for singleton beans).",
        "Prototype beans require manual destruction; Spring does not manage their cleanup."
      ]
    },
    "askedBy": [
      "interview",
      "quiz"
    ],
    "technology": "Spring Boot"
  },
  {
    "id": "43",
    "question": "How would you design/implement Bean lifecycle in a production system?",
    "options": [],
    "answer": "In a production system, manage the Spring Bean lifecycle by using appropriate scopes, leveraging initialization and destruction callbacks, minimizing resource usage, and ensuring proper dependency injection and cleanup for singleton and prototype beans.",
    "type": "Interview",
    "difficulty": "Hard",
    "isObjective": false,
    "explanation": {
      "intro": "Proper Bean lifecycle management in production ensures efficient resource usage, predictable behavior, and maintainable code.",
      "points": [
        "Use correct bean scopes: singleton for shared instances, prototype for per-use instances, request/session for web applications.",
        "Leverage lifecycle callbacks: @PostConstruct, InitializingBean for initialization; @PreDestroy, DisposableBean for cleanup.",
        "Avoid heavy operations in init methods to prevent startup delays.",
        "Ensure dependencies are properly injected and validated.",
        "For prototype beans, handle destruction manually to avoid resource leaks.",
        "Use lazy initialization for non-critical beans to improve startup performance.",
        "Monitor and log lifecycle events for troubleshooting in production.",
        "Document initialization and destruction order for beans with dependencies.",
        "Avoid blocking or long-running operations in lifecycle methods."
      ]
    },
    "askedBy": [
      "interview",
      "system-design"
    ],
    "technology": "Spring Boot"
  },
  {
    "id": "44",
    "question": "Which statement about AOP is correct?",
    "options": [
      "Spring AOP applies aspects only to methods in beans managed by the Spring container.",
      "Spring AOP automatically applies aspects to all classes, including those not managed by Spring.",
      "Spring AOP replaces all method implementations with aspect logic.",
      "Spring AOP requires explicit XML configuration for every method to apply aspects."
    ],
    "answer": "Spring AOP applies aspects only to methods in beans managed by the Spring container.",
    "type": "MCQ",
    "difficulty": "Medium",
    "isObjective": true,
    "explanation": {
      "intro": "Spring AOP provides declarative aspect-oriented programming, applying cross-cutting concerns via proxies on Spring-managed beans.",
      "points": [
        "Aspects are applied using proxies created by the Spring container.",
        "Only Spring-managed beans are eligible for advice execution.",
        "Advice types include @Before, @After, @Around, @AfterReturning, @AfterThrowing.",
        "By default, Spring AOP is proxy-based and does not modify target class bytecode.",
        "AspectJ full weaving is required for non-Spring-managed objects or more advanced use cases."
      ]
    },
    "askedBy": [
      "interview",
      "quiz"
    ],
    "technology": "Spring AOP"
  },
  {
    "id": "45",
    "question": "Describe pros and cons of AOP.",
    "options": [],
    "answer": "AOP in Spring allows modularizing cross-cutting concerns like logging, security, and transactions, improving maintainability, but it can add complexity, obscure control flow, and impact performance if overused.",
    "type": "Interview",
    "difficulty": "Medium",
    "isObjective": false,
    "explanation": {
      "intro": "Aspect-Oriented Programming (AOP) helps separate cross-cutting concerns from business logic, but using it requires careful design to avoid complexity and performance issues.",
      "pros": [
        "Modularizes cross-cutting concerns such as logging, security, and transactions.",
        "Improves maintainability and code readability by separating concerns.",
        "Reduces code duplication across multiple classes or methods.",
        "Supports declarative programming with annotations and configuration.",
        "Easier to apply changes to cross-cutting concerns without touching business logic."
      ],
      "cons": [
        "May increase application complexity if overused.",
        "Can make control flow harder to follow, reducing code readability.",
        "Performance overhead due to proxy creation and advice execution.",
        "Testing can be more complicated as aspects may affect multiple classes/methods.",
        "Debugging issues may be harder due to indirect execution paths."
      ]
    },
    "askedBy": [
      "interview",
      "quiz"
    ],
    "technology": "Spring AOP"
  },
  {
    "id": "46",
    "question": "What is the default behavior of Security in Spring Boot?",
    "options": [
      "All endpoints are publicly accessible without authentication",
      "All endpoints are secured and require authentication by default",
      "Security only applies to database operations",
      "Security automatically encrypts all request payloads"
    ],
    "answer": "All endpoints are secured and require authentication by default",
    "type": "MCQ",
    "difficulty": "Medium",
    "isObjective": true,
    "explanation": {
      "intro": "Spring Boot Security, when included in a project, automatically secures all HTTP endpoints by requiring authentication.",
      "points": [
        "By default, Spring Boot applies basic HTTP authentication to all endpoints.",
        "Endpoints require a valid user with credentials defined in memory or external authentication provider.",
        "Developers can customize security rules to permit or restrict access to specific endpoints.",
        "Security can be configured using WebSecurityConfigurerAdapter or the newer SecurityFilterChain approach.",
        "Spring Security provides protection against common threats such as CSRF, XSS, and session fixation."
      ]
    },
    "askedBy": [
      "interview",
      "quiz"
    ],
    "technology": "Spring Boot Security"
  },
  {
    "id": "47",
    "question": "Describe pros and cons of Security.",
    "options": [],
    "answer": "Spring Boot Security provides robust authentication, authorization, and protection against common threats, but it can add configuration complexity, may impact performance, and requires careful maintenance to avoid vulnerabilities.",
    "type": "Interview",
    "difficulty": "Medium",
    "isObjective": false,
    "explanation": {
      "intro": "Spring Boot Security secures applications at multiple layers, offering built-in mechanisms for authentication and authorization, while also introducing potential complexity.",
      "pros": [
        "Provides built-in authentication and authorization mechanisms.",
        "Protects against common web vulnerabilities such as CSRF, XSS, and session fixation.",
        "Supports OAuth2, JWT, LDAP, and other authentication providers.",
        "Enables role-based and method-level access control.",
        "Auto-configuration simplifies initial security setup."
      ],
      "cons": [
        "Adds learning curve and configuration complexity.",
        "Misconfiguration can introduce vulnerabilities.",
        "May add performance overhead if too many security filters are applied.",
        "Custom security requirements may require significant additional development.",
        "Ongoing maintenance is needed to handle evolving security threats."
      ]
    },
    "askedBy": [
      "interview",
      "quiz"
    ],
    "technology": "Spring Boot Security"
  },
  {
    "id": "48",
    "question": "Which annotation/keyword is used for Data JPA?",
    "options": [
      "@Entity",
      "@Repository",
      "@Transactional",
      "All of the above"
    ],
    "answer": "All of the above",
    "type": "MCQ",
    "difficulty": "Easy",
    "isObjective": true,
    "explanation": {
      "intro": "Spring Data JPA uses multiple annotations to define entities, repositories, and manage transactions.",
      "points": [
        "@Entity marks a class as a JPA entity mapped to a database table.",
        "@Repository marks a class as a Data Access Object (DAO) and enables exception translation.",
        "@Transactional is used to manage transaction boundaries for repository or service methods.",
        "Together, these annotations enable seamless integration with Spring Data JPA for CRUD operations and query methods."
      ]
    },
    "askedBy": [
      "interview",
      "quiz"
    ],
    "technology": "Spring Data JPA"
  },
  {
    "id": "49",
    "question": "Explain how Data JPA works in Spring Boot.",
    "options": [],
    "answer": "Spring Data JPA in Spring Boot simplifies database access by providing repositories that handle CRUD operations, query methods, and transactions, using JPA entities and the Spring container for dependency injection and transaction management.",
    "type": "Interview",
    "difficulty": "Medium",
    "isObjective": false,
    "explanation": {
      "intro": "Spring Data JPA provides a high-level abstraction over JPA, reducing boilerplate code for database interactions.",
      "points": [
        "Define JPA entities using @Entity and map them to database tables.",
        "Create repository interfaces by extending JpaRepository or CrudRepository; Spring Boot generates implementation automatically.",
        "Repositories provide CRUD methods, pagination, sorting, and support for custom query methods.",
        "Transaction management is handled using @Transactional, either at the service or repository level.",
        "Spring Boot auto-configuration detects DataSource and EntityManager, managing the persistence context automatically.",
        "Developers focus on business logic while Spring Data JPA handles database interactions and transactions efficiently."
      ]
    },
    "askedBy": [
      "interview",
      "quiz"
    ],
    "technology": "Spring Boot / Spring Data JPA"
  },
  {
    "id": "50",
    "question": "Describe pros and cons of Actuator.",
    "options": [],
    "answer": "Spring Boot Actuator provides built-in endpoints for monitoring and managing applications, offering valuable insights, but enabling too many endpoints can expose sensitive information and add performance overhead.",
    "type": "Interview",
    "difficulty": "Medium",
    "isObjective": false,
    "explanation": {
      "intro": "Spring Boot Actuator helps monitor and manage applications by exposing operational information via REST endpoints or JMX.",
      "pros": [
        "Provides ready-to-use endpoints for health, metrics, environment, and application info.",
        "Supports integration with monitoring tools like Prometheus, Grafana, and Micrometer.",
        "Enables runtime management, such as logging level changes and thread dump analysis.",
        "Reduces the need for custom monitoring code, saving development time.",
        "Enhances observability and aids in quick troubleshooting."
      ],
      "cons": [
        "Exposing sensitive endpoints without proper security can lead to vulnerabilities.",
        "Enabling too many endpoints may introduce performance overhead.",
        "Customizing or extending endpoints requires understanding of Actuator internals.",
        "Excessive monitoring data can overwhelm logs or monitoring systems if not managed properly."
      ]
    },
    "askedBy": [
      "interview",
      "quiz"
    ],
    "technology": "Spring Boot Actuator"
  },
  {
    "id": "51",
    "question": "What is the purpose of Security in Spring Boot?",
    "options": [
      "To manage HTTP requests and responses",
      "To provide authentication, authorization, and protect applications from common security threats",
      "To configure database transactions automatically",
      "To handle bean lifecycle events"
    ],
    "answer": "To provide authentication, authorization, and protect applications from common security threats",
    "type": "MCQ",
    "difficulty": "Easy",
    "isObjective": true,
    "explanation": {
      "intro": "Spring Boot Security secures applications by managing authentication and authorization, and protecting against common web vulnerabilities.",
      "points": [
        "Supports various authentication methods: in-memory, JDBC, LDAP, OAuth2, JWT, etc.",
        "Enables role-based and method-level access control.",
        "Protects against common attacks like CSRF, XSS, and session fixation.",
        "Allows fine-grained control over which endpoints are secured or publicly accessible.",
        "Integrates with Spring Boot auto-configuration for minimal setup."
      ]
    },
    "askedBy": [
      "interview",
      "quiz"
    ],
    "technology": "Spring Boot Security"
  },
  {
    "id": "52",
    "question": "Explain how Security works in Spring Boot.",
    "options": [],
    "answer": "Spring Boot Security works by intercepting HTTP requests using a security filter chain, authenticating users, authorizing access based on roles/permissions, and protecting applications from common security threats like CSRF and XSS.",
    "type": "Interview",
    "difficulty": "Medium",
    "isObjective": false,
    "explanation": {
      "intro": "Spring Boot Security integrates seamlessly with Spring applications to provide authentication, authorization, and protection from common attacks.",
      "points": [
        "SecurityFilterChain intercepts incoming HTTP requests to apply security rules.",
        "Authentication can be performed via in-memory users, JDBC, LDAP, OAuth2, or JWT.",
        "Authorization is enforced via roles, authorities, or method-level annotations like @PreAuthorize.",
        "CSRF protection is enabled by default for web applications.",
        "Developers can customize security rules using WebSecurityConfigurerAdapter or SecurityFilterChain beans.",
        "Spring Security integrates with Spring Boot auto-configuration to minimize boilerplate setup."
      ]
    },
    "askedBy": [
      "interview",
      "quiz"
    ],
    "technology": "Spring Boot Security"
  },
  {
    "id": "53",
    "question": "What is the purpose of Dependency Injection in Spring Boot?",
    "options": [
      "To manually create and manage all bean dependencies",
      "To allow the framework to automatically provide required dependencies to beans",
      "To handle HTTP requests and responses",
      "To manage application security"
    ],
    "answer": "To allow the framework to automatically provide required dependencies to beans",
    "type": "MCQ",
    "difficulty": "Easy",
    "isObjective": true,
    "explanation": {
      "intro": "Dependency Injection (DI) in Spring Boot allows automatic management of bean dependencies, reducing boilerplate code and promoting loose coupling.",
      "points": [
        "Spring container automatically injects dependencies into beans using constructor, setter, or field injection.",
        "DI promotes loose coupling and easier unit testing.",
        "Developers do not need to manually instantiate or wire dependent objects.",
        "Spring Boot auto-configuration detects beans and manages their lifecycle efficiently."
      ]
    },
    "askedBy": [
      "interview",
      "quiz"
    ],
    "technology": "Spring Boot"
  },
  {
    "id": "54",
    "question": "How would you design/implement Dependency Injection in a production system?",
    "options": [],
    "answer": "In a production system, implement Dependency Injection by defining beans with proper scopes, using constructor injection for immutability, leveraging Spring Boot auto-configuration, managing complex dependencies with @Qualifier, and ensuring testability and maintainability.",
    "type": "Interview",
    "difficulty": "Hard",
    "isObjective": false,
    "explanation": {
      "intro": "Proper design of Dependency Injection in production ensures maintainable, testable, and decoupled applications.",
      "points": [
        "Use constructor injection wherever possible for mandatory dependencies; setter injection for optional dependencies.",
        "Define beans with appropriate scopes: singleton, prototype, request, or session depending on usage.",
        "Use @Autowired, @Qualifier, and @Primary to manage multiple bean candidates clearly.",
        "Leverage Spring Boot auto-configuration to reduce boilerplate and avoid manual wiring.",
        "Ensure unit and integration tests can mock dependencies easily.",
        "Avoid circular dependencies by carefully designing bean relationships.",
        "Lazy initialization can be used for heavy or infrequently used beans to optimize startup performance.",
        "Document bean dependencies and lifecycle for maintainability."
      ]
    },
    "askedBy": [
      "interview",
      "system-design"
    ],
    "technology": "Spring Boot"
  },
  {
    "id": "55",
    "question": "What is the purpose of Actuator in Spring Boot?",
    "options": [],
    "answer": "Spring Boot Actuator provides production-ready features to monitor and manage applications, such as health checks, metrics, and environment information.",
    "type": "Interview",
    "difficulty": "Medium",
    "isObjective": false,
    "explanation": {
      "intro": "Spring Boot Actuator exposes operational information about the running application, helping developers and operators monitor and manage production systems effectively.",
      "points": [
        "Provides endpoints like /health, /metrics, /env, /info, /loggers for monitoring and management.",
        "Integrates with monitoring tools such as Prometheus, Grafana, and Micrometer.",
        "Enables runtime management, including changing logging levels and checking thread dumps.",
        "Reduces the need for custom monitoring code by offering ready-to-use endpoints.",
        "Enhances observability and aids in troubleshooting application issues quickly."
      ]
    },
    "askedBy": [
      "interview",
      "quiz"
    ],
    "technology": "Spring Boot Actuator"
  },
  {
    "id": "56",
    "question": "Explain how Actuator works in Spring Boot.",
    "options": [],
    "answer": "Spring Boot Actuator works by exposing built-in endpoints for application monitoring and management, providing metrics, health checks, environment info, and operational insights via HTTP, JMX, or custom endpoints.",
    "type": "Interview",
    "difficulty": "Medium",
    "isObjective": false,
    "explanation": {
      "intro": "Actuator integrates with Spring Boot applications to provide operational information and management capabilities without additional coding.",
      "points": [
        "Built-in endpoints such as /health, /metrics, /info, /env, /loggers, and /threaddump are exposed for monitoring.",
        "Metrics are collected via Micrometer and can be exported to monitoring systems like Prometheus and Grafana.",
        "Health indicators report the status of database connections, disk space, and other critical components.",
        "Endpoints can be accessed over HTTP or JMX and can be secured using Spring Security.",
        "Custom endpoints can be created by implementing the Endpoint interface or using @Endpoint annotations.",
        "Actuator reduces boilerplate code and simplifies application observability in production."
      ]
    },
    "askedBy": [
      "interview",
      "quiz"
    ],
    "technology": "Spring Boot Actuator"
  },
  {
    "id": "57",
    "question": "What is the default behavior of Profiles in Spring Boot?",
    "options": [
      "All profiles are active by default",
      "No profile is active unless explicitly specified",
      "Profiles are automatically chosen based on the operating system",
      "Profiles are only used for security configurations"
    ],
    "answer": "No profile is active unless explicitly specified",
    "type": "MCQ",
    "difficulty": "Easy",
    "isObjective": true,
    "explanation": {
      "intro": "Spring Boot Profiles allow applications to load environment-specific configurations, but by default, no profile is active unless explicitly set.",
      "points": [
        "Profiles can be set using application.properties/yaml with spring.profiles.active property.",
        "They can also be set via environment variables or command-line arguments.",
        "Default profile is used if no other profile is active.",
        "Profiles help in separating configurations for dev, test, and production environments."
      ]
    },
    "askedBy": [
      "interview",
      "quiz"
    ],
    "technology": "Spring Boot"
  },
  {
    "id": "58",
    "question": "How would you design/implement Profiles in a production system?",
    "options": [],
    "answer": "In a production system, implement Spring Boot Profiles by creating separate configuration files for each environment, activating the appropriate profile at runtime via environment variables or command-line arguments, and using profiles to manage environment-specific beans, properties, and resources.",
    "type": "Interview",
    "difficulty": "Medium",
    "isObjective": false,
    "explanation": {
      "intro": "Spring Boot Profiles allow environment-specific configurations and beans, which is essential for managing multiple deployment environments in production.",
      "points": [
        "Create separate application-{profile}.properties or application-{profile}.yaml files for each environment (dev, test, prod).",
        "Activate profiles using spring.profiles.active property via environment variables, JVM arguments, or cloud configuration.",
        "Use @Profile annotation to define beans that should only be instantiated in specific environments.",
        "Combine profiles to create environment-specific combinations (e.g., dev + debug).",
        "Avoid hardcoding environment-specific values; rely on profiles to switch configurations.",
        "Profiles ensure clean separation of configuration and reduce the risk of deploying incorrect settings."
      ]
    },
    "askedBy": [
      "interview",
      "system-design"
    ],
    "technology": "Spring Boot"
  },
  {
    "id": "59",
    "question": "What is the default behavior of Controllers in Spring Boot?",
    "options": [
      "Controllers handle HTTP requests and return views or responses by default",
      "Controllers automatically manage bean lifecycles",
      "Controllers provide security and authentication by default",
      "Controllers are used only for database transactions"
    ],
    "answer": "Controllers handle HTTP requests and return views or responses by default",
    "type": "MCQ",
    "difficulty": "Easy",
    "isObjective": true,
    "explanation": {
      "intro": "In Spring Boot, Controllers are used to handle incoming HTTP requests and produce responses, either as views or as data.",
      "points": [
        "Annotated with @Controller or @RestController.",
        "@Controller typically returns a view, while @RestController returns data directly (JSON/XML).",
        "Methods are mapped to URLs using @RequestMapping, @GetMapping, @PostMapping, etc.",
        "Controllers are managed by the Spring container and can have dependencies injected.",
        "They form the web layer in Spring MVC architecture."
      ]
    },
    "askedBy": [
      "interview",
      "quiz"
    ],
    "technology": "Spring Boot MVC"
  },
  {
    "id": "60",
    "question": "What is the default behavior of Actuator in Spring Boot?",
    "options": [
      "All endpoints are disabled by default",
      "Only health and info endpoints are enabled by default",
      "All endpoints are enabled and unsecured by default",
      "Actuator automatically modifies application business logic"
    ],
    "answer": "Only health and info endpoints are enabled by default",
    "type": "MCQ",
    "difficulty": "Medium",
    "isObjective": true,
    "explanation": {
      "intro": "Spring Boot Actuator exposes operational endpoints for monitoring and management, but only a minimal set is enabled by default.",
      "points": [
        "By default, /actuator/health and /actuator/info are enabled.",
        "Other endpoints like /metrics, /env, /loggers need to be explicitly enabled in configuration.",
        "Endpoints can be secured using Spring Security to prevent unauthorized access.",
        "This default behavior ensures minimal exposure of sensitive operational data."
      ]
    },
    "askedBy": [
      "interview",
      "quiz"
    ],
    "technology": "Spring Boot Actuator"
  },
  {
    "id": "61",
    "question": "How would you design/implement Actuator in a production system?",
    "options": [],
    "answer": "In a production system, implement Spring Boot Actuator by enabling only necessary endpoints, securing them with Spring Security, integrating with monitoring tools like Prometheus or Grafana, and configuring proper logging and metrics collection.",
    "type": "Interview",
    "difficulty": "Medium",
    "isObjective": false,
    "explanation": {
      "intro": "Proper implementation of Actuator in production ensures observability, performance monitoring, and security without exposing sensitive information.",
      "points": [
        "Enable only the endpoints needed for monitoring and management (e.g., /health, /metrics).",
        "Secure actuator endpoints using Spring Security to restrict access to authorized personnel.",
        "Integrate with monitoring systems like Prometheus, Grafana, or ELK for metrics visualization and alerts.",
        "Configure metrics, logging, and health indicators for critical components.",
        "Use custom endpoints if necessary to expose application-specific operational data.",
        "Avoid exposing sensitive configuration properties publicly.",
        "Monitor performance impact and tune endpoints to minimize overhead.",
        "Document actuator setup and usage for DevOps and operations teams."
      ]
    },
    "askedBy": [
      "interview",
      "system-design"
    ],
    "technology": "Spring Boot Actuator"
  },
  {
    "id": "62",
    "question": "Which command is used to Controllers in Spring Boot?",
    "options": [
      "@Controller",
      "@RestController",
      "@RequestMapping/@GetMapping/@PostMapping",
      "All of the above"
    ],
    "answer": "All of the above",
    "type": "MCQ",
    "difficulty": "Easy",
    "isObjective": true,
    "explanation": {
      "intro": "Spring Boot Controllers are defined using annotations that handle HTTP requests and map them to methods.",
      "points": [
        "@Controller marks a class as a Spring MVC controller, returning views.",
        "@RestController is a convenience annotation that combines @Controller and @ResponseBody, returning data (JSON/XML) directly.",
        "@RequestMapping, @GetMapping, @PostMapping map HTTP requests to specific controller methods.",
        "Together, these annotations allow handling of web requests efficiently and declaratively."
      ]
    },
    "askedBy": [
      "interview",
      "quiz"
    ],
    "technology": "Spring Boot MVC"
  },
  {
    "id": "63",
    "question": "Which statement about Data JPA is correct?",
    "options": [
      "Spring Data JPA provides boilerplate-free CRUD operations via repository interfaces",
      "Data JPA automatically creates database tables without entities",
      "Spring Data JPA replaces the need for transactions in applications",
      "Data JPA does not support custom queries"
    ],
    "answer": "Spring Data JPA provides boilerplate-free CRUD operations via repository interfaces",
    "type": "MCQ",
    "difficulty": "Medium",
    "isObjective": true,
    "explanation": {
      "intro": "Spring Data JPA simplifies database access by providing repository abstractions over JPA entities.",
      "points": [
        "Define repository interfaces extending JpaRepository or CrudRepository; Spring generates implementations automatically.",
        "Supports CRUD operations, pagination, sorting, and custom queries with method naming conventions or @Query annotation.",
        "Requires JPA entities annotated with @Entity to map to database tables.",
        "Transaction management is handled via @Transactional for service or repository methods."
      ]
    },
    "askedBy": [
      "interview",
      "quiz"
    ],
    "technology": "Spring Data JPA"
  },
  {
    "id": "64",
    "question": "How would you design/implement Data JPA in a production system?",
    "options": [],
    "answer": "In a production system, implement Data JPA by defining JPA entities with proper relationships, using repository interfaces for CRUD operations, managing transactions with @Transactional, optimizing queries with indexing, and integrating with connection pools and caching for performance.",
    "type": "Interview",
    "difficulty": "Hard",
    "isObjective": false,
    "explanation": {
      "intro": "Proper use of Spring Data JPA in production ensures efficient, maintainable, and scalable database interactions.",
      "points": [
        "Define JPA entities with correct annotations (@Entity, @Id, @OneToMany, @ManyToOne, etc.) to model the domain.",
        "Use repository interfaces extending JpaRepository or CrudRepository for CRUD operations, pagination, and sorting.",
        "Manage transaction boundaries using @Transactional to ensure data consistency.",
        "Optimize database access with proper indexing, lazy/eager loading strategies, and caching where appropriate.",
        "Avoid N+1 query problems by using fetch joins or EntityGraph.",
        "Configure connection pools (HikariCP) for efficient database connections.",
        "Write integration tests to validate repository and entity behavior.",
        "Leverage Spring Boot auto-configuration to minimize boilerplate while keeping production performance in mind."
      ]
    },
    "askedBy": [
      "interview",
      "system-design"
    ],
    "technology": "Spring Data JPA"
  },
  {
    "id": "65",
    "question": "Which statement about Security is correct?",
    "options": [
      "Spring Security automatically encrypts all data in the database",
      "Spring Security provides authentication and authorization mechanisms for web applications",
      "Spring Security replaces the need for controllers in Spring Boot",
      "Spring Security manages dependency injection automatically"
    ],
    "answer": "Spring Security provides authentication and authorization mechanisms for web applications",
    "type": "MCQ",
    "difficulty": "Medium",
    "isObjective": true,
    "explanation": {
      "intro": "Spring Security secures applications by providing authentication and authorization, as well as protection against common web vulnerabilities.",
      "points": [
        "Supports various authentication methods: in-memory, JDBC, LDAP, OAuth2, JWT, etc.",
        "Enables role-based and method-level access control for endpoints and services.",
        "Protects applications from common attacks like CSRF, XSS, and session fixation.",
        "Integrates seamlessly with Spring Boot auto-configuration for minimal setup."
      ]
    },
    "askedBy": [
      "interview",
      "quiz"
    ],
    "technology": "Spring Boot Security"
  },
  {
    "id": "66",
    "question": "How would you design/implement Security in a production system?",
    "options": [],
    "answer": "In a production system, implement Security by enforcing authentication and authorization, securing endpoints with roles/permissions, integrating with OAuth2/JWT or LDAP, applying HTTPS, enabling CSRF/XSS protection, and continuously monitoring and updating security policies.",
    "type": "Interview",
    "difficulty": "Hard",
    "isObjective": false,
    "explanation": {
      "intro": "Proper security implementation ensures that Spring Boot applications are protected from unauthorized access and common vulnerabilities in production.",
      "points": [
        "Use HTTPS to secure communication between client and server.",
        "Implement authentication using OAuth2, JWT, LDAP, or in-memory providers depending on requirements.",
        "Define authorization rules using roles, authorities, and method-level annotations like @PreAuthorize or @Secured.",
        "Enable CSRF protection and other security headers to prevent common web attacks.",
        "Secure actuator endpoints and sensitive APIs to restrict access to authorized personnel only.",
        "Regularly update dependencies and monitor for vulnerabilities.",
        "Use logging and monitoring to detect unauthorized access or security breaches.",
        "Apply the principle of least privilege for users and services."
      ]
    },
    "askedBy": [
      "interview",
      "system-design"
    ],
    "technology": "Spring Boot Security"
  },
  {
    "id": "67",
    "question": "Which statement about Transactions is correct?",
    "options": [
      "Transactions ensure data consistency and integrity by grouping multiple operations as a single unit of work",
      "Transactions automatically improve application performance without configuration",
      "Transactions replace the need for Dependency Injection",
      "Transactions only work with REST APIs"
    ],
    "answer": "Transactions ensure data consistency and integrity by grouping multiple operations as a single unit of work",
    "type": "MCQ",
    "difficulty": "Medium",
    "isObjective": true,
    "explanation": {
      "intro": "Transactions in Spring Boot ensure that multiple operations are executed as a single unit, maintaining consistency and integrity of data.",
      "points": [
        "Annotated with @Transactional to define transaction boundaries.",
        "All operations within a transaction either succeed together or roll back on failure.",
        "Supports propagation and isolation levels to control transaction behavior.",
        "Essential for maintaining consistent state in databases and avoiding partial updates."
      ]
    },
    "askedBy": [
      "interview",
      "quiz"
    ],
    "technology": "Spring Boot / Transactions"
  },
  {
    "id": "68",
    "question": "Explain how Transactions works in Spring Boot.",
    "options": [],
    "answer": "Transactions in Spring Boot work by wrapping a set of operations within a transaction boundary using @Transactional. If all operations succeed, the transaction is committed; if any operation fails, it is rolled back to maintain data consistency.",
    "type": "Interview",
    "difficulty": "Medium",
    "isObjective": false,
    "explanation": {
      "intro": "Spring Boot manages transactions declaratively or programmatically to ensure data consistency across multiple operations.",
      "points": [
        "@Transactional annotation defines transaction boundaries on methods or classes.",
        "Spring uses PlatformTransactionManager to manage transactions with the underlying database.",
        "Propagation settings define how transactions behave when nested or called from other transactions.",
        "Isolation levels control visibility of data changes between concurrent transactions.",
        "Rollback rules can be configured for specific exceptions to ensure data integrity.",
        "Spring Boot auto-configuration detects DataSource and transaction manager, simplifying setup."
      ]
    },
    "askedBy": [
      "interview",
      "quiz"
    ],
    "technology": "Spring Boot / Transactions"
  },
  {
    "id": "69",
    "question": "What is the default behavior of Security in Spring Boot?",
    "options": [
      "All endpoints are publicly accessible by default",
      "All endpoints require authentication with a generated default user and password",
      "Security is disabled by default",
      "Only /actuator endpoints are secured by default"
    ],
    "answer": "All endpoints require authentication with a generated default user and password",
    "type": "MCQ",
    "difficulty": "Medium",
    "isObjective": true,
    "explanation": {
      "intro": "Spring Boot Security secures applications by default, requiring authentication for all HTTP endpoints unless configured otherwise.",
      "points": [
        "Spring Boot auto-configures a default user with a generated password on startup.",
        "All HTTP endpoints are secured by default, except static resources.",
        "Developers can customize security configurations using WebSecurityConfigurerAdapter or SecurityFilterChain.",
        "This behavior ensures minimal exposure and encourages secure applications out-of-the-box."
      ]
    },
    "askedBy": [
      "interview",
      "quiz"
    ],
    "technology": "Spring Boot Security"
  },
  {
    "id": "70",
    "question": "Which command/annotation is used to implement AOP in Spring Boot?",
    "options": [
      "@Aspect",
      "@Transactional",
      "@Controller",
      "@RestController"
    ],
    "answer": "@Aspect",
    "type": "MCQ",
    "difficulty": "Easy",
    "isObjective": true,
    "explanation": {
      "intro": "Spring AOP (Aspect-Oriented Programming) uses @Aspect to define cross-cutting concerns such as logging, security, or transactions.",
      "points": [
        "@Aspect marks a class as an aspect containing advice (before, after, around).",
        "Advice methods are applied to join points (specific points in the program execution) using pointcut expressions.",
        "Spring AOP integrates with Spring Beans to apply aspects without modifying existing business logic.",
        "Common use cases include logging, performance monitoring, security checks, and transaction management."
      ]
    },
    "askedBy": [
      "interview",
      "quiz"
    ],
    "technology": "Spring Boot AOP"
  },
  {
    "id": "71",
    "question": "Explain how AOP works in Spring Boot.",
    "options": [],
    "answer": "Spring Boot AOP works by defining aspects with @Aspect, which contain advice methods that are applied to specific join points (method executions, etc.) using pointcut expressions, allowing cross-cutting concerns like logging or transactions to be implemented separately from business logic.",
    "type": "Interview",
    "difficulty": "Medium",
    "isObjective": false,
    "explanation": {
      "intro": "Aspect-Oriented Programming (AOP) in Spring Boot allows separation of cross-cutting concerns from core business logic.",
      "points": [
        "@Aspect annotation marks a class as an aspect containing advice.",
        "Advice types include @Before, @After, @Around, @AfterReturning, and @AfterThrowing.",
        "Pointcut expressions define which methods or classes the advice applies to.",
        "Spring AOP weaves these aspects into Spring-managed beans at runtime.",
        "Common use cases include logging, performance monitoring, security, and transaction management.",
        "AOP reduces code duplication and improves maintainability by separating concerns."
      ]
    },
    "askedBy": [
      "interview",
      "quiz"
    ],
    "technology": "Spring Boot AOP"
  },
  {
    "id": "72",
    "question": "Which command/annotation is used to define or activate Profiles in Spring Boot?",
    "options": [
      "@Profile",
      "@Controller",
      "@RestController",
      "@Aspect"
    ],
    "answer": "@Profile",
    "type": "MCQ",
    "difficulty": "Easy",
    "isObjective": true,
    "explanation": {
      "intro": "Spring Profiles allow beans or configurations to be loaded conditionally based on the active profile.",
      "points": [
        "@Profile annotation is used on @Component, @Configuration, or @Bean to specify the environment(s) where the bean should be active.",
        "Profiles can be activated via application.properties/yaml using spring.profiles.active, environment variables, or command-line arguments.",
        "This mechanism helps in separating configurations for dev, test, and production environments.",
        "Only beans matching the active profile(s) are registered in the Spring context."
      ]
    },
    "askedBy": [
      "interview",
      "quiz"
    ],
    "technology": "Spring Boot Profiles"
  },
  {
    "id": "73",
    "question": "Describe pros and cons of Dependency Injection.",
    "options": [],
    "answer": "Dependency Injection promotes loose coupling and easier testing but can increase complexity if overused and may require additional configuration.",
    "type": "Interview",
    "difficulty": "Medium",
    "isObjective": false,
    "explanation": {
      "intro": "Dependency Injection (DI) is a design pattern in Spring Boot that allows automatic provision of required dependencies to beans, but it has both advantages and drawbacks.",
      "points": [
        "Pros:",
        "1. Loose coupling: Classes do not create their own dependencies, making code more modular.",
        "2. Easier testing: Dependencies can be mocked or stubbed in unit tests.",
        "3. Maintainability: Changing a dependency does not require changes in dependent classes.",
        "4. Reusability: Beans can be reused across different components.",
        "Cons:",
        "1. Complexity: Overuse can make it harder to understand the flow of dependencies.",
        "2. Learning curve: New developers may find DI and configuration confusing.",
        "3. Runtime errors: Missing or misconfigured dependencies may only show up at runtime.",
        "4. Overhead: Small applications might have unnecessary configuration overhead."
      ]
    },
    "askedBy": [
      "interview",
      "quiz"
    ],
    "technology": "Spring Boot / Dependency Injection"
  },
  {
    "id": "74",
    "question": "Which command/annotation is used to manage Bean Lifecycle in Spring Boot?",
    "options": [
      "@PostConstruct / @PreDestroy",
      "@Controller / @RestController",
      "@Transactional",
      "@Aspect"
    ],
    "answer": "@PostConstruct / @PreDestroy",
    "type": "MCQ",
    "difficulty": "Easy",
    "isObjective": true,
    "explanation": {
      "intro": "Spring Bean lifecycle can be managed using annotations that allow initialization and destruction callbacks for beans.",
      "points": [
        "@PostConstruct is called after the bean is initialized and dependencies are injected.",
        "@PreDestroy is called just before the bean is removed from the container.",
        "These annotations help in performing setup or cleanup tasks for beans.",
        "Custom init and destroy methods can also be specified in @Bean definitions."
      ]
    },
    "askedBy": [
      "interview",
      "quiz"
    ],
    "technology": "Spring Boot / Bean Lifecycle"
  },
  {
    "id": "75",
    "question": "What is the purpose of Transactions in Spring Boot?",
    "options": [
      "To ensure a group of operations succeed or fail as a single unit, maintaining data consistency",
      "To automatically inject dependencies into beans",
      "To secure HTTP endpoints in an application",
      "To manage bean lifecycle callbacks"
    ],
    "answer": "To ensure a group of operations succeed or fail as a single unit, maintaining data consistency",
    "type": "MCQ",
    "difficulty": "Medium",
    "isObjective": true,
    "explanation": {
      "intro": "Transactions in Spring Boot provide a mechanism to manage multiple operations as a single unit of work, ensuring consistency and integrity.",
      "points": [
        "Annotated with @Transactional to define transaction boundaries.",
        "If any operation within the transaction fails, all operations are rolled back.",
        "Supports propagation and isolation levels to control transactional behavior.",
        "Critical for database operations that must be atomic and consistent."
      ]
    },
    "askedBy": [
      "interview",
      "quiz"
    ],
    "technology": "Spring Boot / Transactions"
  },
  {
    "id": "76",
    "question": "Which annotation/keyword is used for Auto-configuration in Spring Boot?",
    "options": [
      "@EnableAutoConfiguration",
      "@SpringBootApplication",
      "@Configuration",
      "All of the above"
    ],
    "answer": "All of the above",
    "type": "MCQ",
    "difficulty": "Easy",
    "isObjective": true,
    "explanation": {
      "intro": "Spring Boot uses Auto-configuration to automatically configure beans and settings based on the classpath and defined beans.",
      "points": [
        "@EnableAutoConfiguration enables Spring Boot’s auto-configuration mechanism.",
        "@SpringBootApplication is a meta-annotation that includes @EnableAutoConfiguration, @ComponentScan, and @Configuration.",
        "@Configuration indicates that the class declares one or more @Bean methods for the Spring container.",
        "Auto-configuration reduces boilerplate and simplifies setup for typical Spring applications."
      ]
    },
    "askedBy": [
      "interview",
      "quiz"
    ],
    "technology": "Spring Boot / Auto-configuration"
  },
  {
    "id": "77",
    "question": "What is Spring Framework?",
    "options": ["A JavaScript library", "A Java framework for enterprise applications", "A database", "A testing tool"],
    "answer": "A Java framework for enterprise applications",
    "isObjective": true,
    "type": "Advance Concepts",
    "explanation": {
      "intro": "The Spring Framework is an open-source Java framework used to build enterprise-level applications. It provides comprehensive infrastructure support for developing Java applications.",
      "points": [
        "Provides dependency injection (DI) and inversion of control (IoC).",
        "Simplifies enterprise application development.",
        "Supports transaction management, AOP (Aspect-Oriented Programming).",
        "Integrates easily with Hibernate, JPA, JMS, and other technologies.",
        "Has specialized modules like Spring MVC, Spring Boot, Spring Security, etc."
      ],
      "code": "import org.springframework.stereotype.Component;\n\n@Component\nclass Engine {}\n\n@Component\nclass Car {\n    private final Engine engine;\n\n    public Car(Engine engine) { // Constructor Injection\n        this.engine = engine;\n    }\n}",
      "diagram": "/diagrams/spring/spring_framework_intro.md"
    }
  },
  {
    "id": "78",
    "question": "What is Dependency Injection in Spring?",
    "options": ["Manual object creation", "A way to reduce dependencies", "A design pattern that allows Spring to manage object creation", "A database operation"],
    "answer": "A design pattern that allows Spring to manage object creation",
    "isObjective": true,
    "type": "Advance Concepts",
    "explanation": {
      "intro": "Dependency Injection (DI) is a design pattern in Spring where the framework is responsible for creating and managing the lifecycle of objects (beans) and injecting them where needed. It removes the need for manual object creation and improves testability and maintainability.",
      "points": [
        "Decouples object creation from business logic.",
        "Improves code reusability and testability.",
        "Supports constructor injection, setter injection, and field injection.",
        "Makes applications loosely coupled."
      ],
      "code": "import org.springframework.stereotype.Component;\nimport org.springframework.beans.factory.annotation.Autowired;\n\n@Component\nclass Engine {}\n\n@Component\nclass Car {\n    private final Engine engine;\n\n    @Autowired\n    public Car(Engine engine) { // Constructor Injection\n        this.engine = engine;\n    }\n}",
      "diagram": "/diagrams/spring/dependency_injection.md"
    }
  },
  {
    "id": "79",
    "question": "Which annotation is used to define a Spring Boot application?",
    "options": ["@Configuration", "@Component", "@SpringBootApplication", "@Service"],
    "answer": "@SpringBootApplication",
    "isObjective": true,
    "type": "Advance Concepts",
    "explanation": {
      "intro": "@SpringBootApplication is a convenience annotation that marks the main class of a Spring Boot application. It bundles three key annotations together.",
      "points": [
        "@Configuration – marks the class as a source of bean definitions.",
        "@EnableAutoConfiguration – enables Spring Boot’s auto-configuration mechanism.",
        "@ComponentScan – enables scanning for components, configurations, and services."
      ],
      "code": "import org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class MyApp {\n    public static void main(String[] args) {\n        SpringApplication.run(MyApp.class, args);\n    }\n}",
      "diagram": "/diagrams/spring/spring_boot_application.md"
    }
  },
  {
    "id": "80",
    "question": "What is the default scope of a Spring bean?",
    "options": ["prototype", "singleton", "request", "session"],
    "answer": "singleton",
    "isObjective": true,
    "type": "MCQ",
    "askedBy": [],
    "explanation": {
      "intro": "In Spring, the default scope of a bean is **singleton**, meaning that only one instance of the bean is created per Spring container.",
      "points": [
        "Singleton: One shared instance of the bean in the container (default).",
        "Prototype: A new instance each time the bean is requested.",
        "Request: A new instance per HTTP request (web-aware).",
        "Session: A new instance per HTTP session (web-aware)."
      ],
      "code": "@Component\npublic class MyService {\n    // By default, this bean will be singleton\n}",
      "diagram": "/diagrams/spring/spring_bean_scope.md"
    }
  },
  {
    "id": "81",
    "question": "Which annotation is used for mapping HTTP requests to handler methods in Spring MVC?",
    "options": ["@Component", "@RequestMapping", "@Autowired", "@RestController"],
    "answer": "@RequestMapping",
    "isObjective": true,
    "type": "MCQ",
    "askedBy": [],
    "explanation": {
      "intro": "In Spring MVC, the `@RequestMapping` annotation is used to map HTTP requests to specific handler methods or controller classes.",
      "points": [
        "`@RequestMapping` can be applied at the **class level** and/or the **method level**.",
        "It supports different HTTP methods such as GET, POST, PUT, DELETE by using `method` attribute.",
        "Specialized annotations like `@GetMapping`, `@PostMapping`, etc., were introduced in Spring 4.3 as shortcuts for `@RequestMapping` with predefined HTTP methods."
      ],
      "code": "@RestController\npublic class MyController {\n\n    @RequestMapping(value = \"/hello\", method = RequestMethod.GET)\n    public String sayHello() {\n        return \"Hello, Spring MVC!\";\n    }\n}",
      "diagram": "/diagrams/spring/request_mapping.md"
    }
  },
  {
    "id": "82",
    "question": "What is the difference between @Component, @Service, and @Repository?",
    "options": [
      "They are exactly the same",
      "They are specializations of @Component with different semantic uses",
      "They are unrelated",
      "Only @Component works in Spring Boot"
    ],
    "answer": "They are specializations of @Component with different semantic uses",
    "isObjective": true,
    "type": "MCQ",
    "askedBy": [],
    "explanation": {
      "intro": "In Spring, `@Component`, `@Service`, and `@Repository` are all stereotype annotations used for marking classes as Spring-managed beans. They serve different semantic purposes.",
      "points": [
        "`@Component` is a generic stereotype for any Spring-managed bean.",
        "`@Service` is a specialization of `@Component`, used to indicate that a class contains business logic.",
        "`@Repository` is also a specialization of `@Component`, typically applied to DAO (Data Access Object) classes. It also provides automatic translation of database-related exceptions into Spring's DataAccessException."
      ],
      "code": "@Component\npublic class UtilityBean {}\n\n@Service\npublic class PaymentService {}\n\n@Repository\npublic class UserRepository {}",
      "diagram": "/diagrams/spring/component_service_repository.md"
    }
  },
  {
    "id": "83",
    "question": "Which annotation is used for automatic dependency injection?",
    "options": ["@Bean", "@Autowired", "@Inject", "@Configuration"],
    "answer": "@Autowired",
    "isObjective": true,
    "type": "MCQ",
    "askedBy": [],
    "explanation": {
      "intro": "In Spring, automatic dependency injection allows the framework to resolve and inject collaborating beans into a class without manual instantiation.",
      "points": [
        "`@Autowired` is the most commonly used annotation for automatic dependency injection in Spring.",
        "`@Inject` (from JSR-330) can also be used, but `@Autowired` is Spring-specific and provides additional options like `required=false`.",
        "`@Bean` defines a bean in a configuration class, not used for injection directly.",
        "`@Configuration` is used to mark a class as a source of bean definitions."
      ],
      "code": "import org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Component;\n\n@Component\nclass Engine {}\n\n@Component\nclass Car {\n    private final Engine engine;\n\n    @Autowired  // automatic injection of Engine bean\n    public Car(Engine engine) {\n        this.engine = engine;\n    }\n}",
      "diagram": "/diagrams/spring/autowired_injection.md"
    }
  },
  {
    "id": "84",
    "question": "What is Spring Boot Starter?",
    "options": ["A test framework", "A collection of dependencies for rapid development", "A logging tool", "An IDE plugin"],
    "answer": "A collection of dependencies for rapid development",
    "isObjective": true,
    "type": "MCQ",
    "askedBy": [],
    "explanation": {
      "intro": "Spring Boot Starters are pre-configured dependency descriptors that simplify project setup and development.",
      "points": [
        "Starters reduce the need to manually define dependencies for common functionality.",
        "Each starter is a Maven or Gradle dependency with a curated set of libraries (e.g., web, JPA, security).",
        "For example, `spring-boot-starter-web` includes Spring MVC, Jackson, and Tomcat by default.",
        "This accelerates development by providing ready-to-use features with minimal setup."
      ],
      "code": "dependencies {\n    implementation 'org.springframework.boot:spring-boot-starter-web'\n    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'\n    testImplementation 'org.springframework.boot:spring-boot-starter-test'\n}",
      "diagram": "/diagrams/spring/spring_boot_starter.md"
    }
  },
  {
    "id": "85",
    "question": "How do you define a bean in Java configuration?",
    "options": ["Using @Bean inside a @Configuration class", "Using @Service", "Using @Entity", "Using @Value"],
    "answer": "Using @Bean inside a @Configuration class",
    "isObjective": true,
    "type": "MCQ",
    "askedBy": [],
    "technology": "Spring",
    "explanation": {
      "intro": "In Spring, beans can be defined using annotations or XML, but with Java-based configuration, the @Bean annotation is used inside a @Configuration class.",
      "points": [
        "A class annotated with `@Configuration` indicates that it contains Spring bean definitions.",
        "`@Bean` methods inside such classes return objects managed by the Spring container.",
        "These beans can then be injected into other components using `@Autowired`.",
        "This approach provides type-safety and is preferred over XML-based configuration."
      ],
      "code": "import org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\npublic class AppConfig {\n\n    @Bean\n    public MyService myService() {\n        return new MyServiceImpl();\n    }\n}",
      "diagram": "/diagrams/spring/spring_bean_definition.md"
    }
  },
  {
    "id": "86",
    "question": "What does @RestController do?",
    "options": [
      "Marks a class as a database repository",
      "Marks a class as a RESTful controller returning JSON/XML",
      "Marks a class as a configuration class",
      "Marks a bean as prototype"
    ],
    "answer": "Marks a class as a RESTful controller returning JSON/XML",
    "isObjective": true,
    "type": "MCQ",
    "askedBy": [],
    "technology": "Spring",
    "explanation": {
      "intro": "@RestController is a specialized annotation in Spring MVC that combines @Controller and @ResponseBody.",
      "points": [
        "It marks a class as a controller where every method returns a domain object instead of a view.",
        "Responses are automatically serialized to JSON or XML based on content negotiation.",
        "Eliminates the need to annotate each method with @ResponseBody individually."
      ],
      "code": "import org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\npublic class UserController {\n\n    @GetMapping(\"/users\")\n    public List<User> getAllUsers() {\n        return userService.findAll();\n    }\n}",
      "diagram": "/diagrams/spring/restcontroller_flow.md"
    }
  },
  {
    "id": "87",
    "question": "What is Spring Data JPA?",
    "options": [
      "A tool for database migrations",
      "A persistence framework simplifying data access with JPA",
      "A JDBC wrapper",
      "A NoSQL framework"
    ],
    "answer": "A persistence framework simplifying data access with JPA",
    "isObjective": true,
    "type": "MCQ",
    "askedBy": [],
    "technology": "Spring",
    "explanation": {
      "intro": "Spring Data JPA is a part of the Spring Data project that simplifies working with JPA-based data access layers.",
      "points": [
        "Reduces boilerplate code required for DAO/repository implementations.",
        "Provides repository interfaces with built-in CRUD operations.",
        "Supports query derivation from method names and custom JPQL/SQL queries."
      ],
      "code": "import org.springframework.data.jpa.repository.JpaRepository;\nimport org.springframework.stereotype.Repository;\n\n@Repository\npublic interface UserRepository extends JpaRepository<User, Long> {\n    List<User> findByLastName(String lastName);\n}",
      "diagram": "/diagrams/spring/spring_data_jpa_flow.md"
    }
  },
  {
    "id": "88",
    "question": "Which annotation is used to mark a class as a configuration class in Spring?",
    "options": ["@Configuration", "@Component", "@RestController", "@Bean"],
    "answer": "@Configuration",
    "isObjective": true,
    "type": "MCQ",
    "askedBy": [],
    "technology": "Spring",
    "explanation": {
      "intro": "The @Configuration annotation indicates that the class declares one or more @Bean methods and may be processed by the Spring container to generate bean definitions and service requests.",
      "points": [
        "@Configuration classes can contain multiple @Bean methods.",
        "Beans defined in @Configuration classes are managed by the Spring container.",
        "Helps in Java-based configuration instead of XML."
      ],
      "code": "import org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\npublic class AppConfig {\n\n    @Bean\n    public MyService myService() {\n        return new MyServiceImpl();\n    }\n}",
      "diagram": "/diagrams/spring/spring_configuration_flow.md"
    }
  },
  {
    "id": "89",
    "question": "What is the purpose of application.properties in Spring Boot?",
    "options": [
      "To store SQL queries",
      "To configure application settings",
      "To define HTML templates",
      "To compile code"
    ],
    "answer": "To configure application settings",
    "isObjective": true,
    "type": "MCQ",
    "askedBy": [],
    "technology": "Spring Boot",
    "explanation": {
      "intro": "The application.properties (or application.yml) file is used to externalize configuration in a Spring Boot application.",
      "points": [
        "It allows you to define database URLs, usernames, and passwords.",
        "You can configure server ports, logging levels, and other application-specific settings.",
        "Supports environment-specific configurations using profiles (e.g., application-dev.properties)."
      ],
      "code": "spring.datasource.url=jdbc:mysql://localhost:3306/mydb\nspring.datasource.username=root\nspring.datasource.password=root\nserver.port=8081\nlogging.level.org.springframework=DEBUG",
      "diagram": "/diagrams/spring/spring_application_properties_flow.md"
    }
  },
  {
    "id": "90",
    "question": "How do you enable scheduling in Spring?",
    "options": ["@Scheduled", "@EnableScheduling", "Both", "None"],
    "answer": "Both",
    "isObjective": true,
    "type": "MCQ",
    "askedBy": [],
    "technology": "Spring Boot",
    "explanation": {
      "intro": "Scheduling in Spring allows methods to run at fixed intervals or cron expressions.",
      "points": [
        "@EnableScheduling is placed on a @Configuration class to enable scheduling support.",
        "@Scheduled is used on methods to define the schedule (fixedRate, fixedDelay, cron).",
        "Both annotations are needed to fully enable scheduled tasks."
      ],
      "code": "@Configuration\n@EnableScheduling\npublic class AppConfig {}\n\n@Component\npublic class ScheduledTasks {\n    @Scheduled(fixedRate = 5000)\n    public void reportCurrentTime() {\n        System.out.println(\"Current time: \" + LocalDateTime.now());\n    }\n}",
      "diagram": "/diagrams/spring/spring_scheduling_flow.md"
    }
  },
  {
    "id": "91",
    "question": "Which annotation is used to create a transactional method in Spring?",
    "options": ["@Transactional", "@Autowired", "@Service", "@Bean"],
    "answer": "@Transactional",
    "isObjective": true,
    "type": "MCQ",
    "askedBy": [],
    "technology": "Spring",
    "explanation": {
      "intro": "@Transactional is used to define the scope of a database transaction in Spring.",
      "points": [
        "Can be applied on methods or classes.",
        "Ensures that a series of operations either complete successfully or roll back on failure.",
        "Supports propagation, isolation, and rollback rules."
      ],
      "code": "@Service\npublic class UserService {\n\n    @Transactional\n    public void createUser(User user) {\n        userRepository.save(user);\n        // additional operations\n    }\n}",
      "diagram": "/diagrams/spring/spring_transaction_flow.md"
    }
  },
  {
    "id": "92",
    "question": "What is Spring AOP?",
    "options": ["Application Oriented Programming", "Aspect Oriented Programming", "Advanced Object Processing", "None"],
    "answer": "Aspect Oriented Programming",
    "isObjective": true,
    "type": "MCQ",
    "askedBy": [],
    "technology": "Spring",
    "explanation": {
      "intro": "Spring AOP (Aspect-Oriented Programming) allows separation of cross-cutting concerns like logging, transactions, and security from business logic.",
      "points": [
        "Enables modularization of concerns that affect multiple classes.",
        "Works using proxies to weave aspects before, after, or around method executions.",
        "Common use-cases: logging, transactions, security checks."
      ],
      "code": "@Aspect\n@Component\npublic class LoggingAspect {\n\n    @Before(\"execution(* com.example.service.*.*(..))\")\n    public void logBefore(JoinPoint joinPoint) {\n        System.out.println(\"Before method: \" + joinPoint.getSignature().getName());\n    }\n}",
      "diagram": "/diagrams/spring/spring_aop_flow.md"
    }
  },
  {
    "id": "93",
    "question": "What is the use of @Value annotation in Spring?",
    "options": [
      "To define entity fields",
      "To inject values from properties files",
      "To mark beans as primary",
      "To map REST endpoints"
    ],
    "answer": "To inject values from properties files",
    "isObjective": true,
    "type": "MCQ",
    "askedBy": [],
    "technology": "Spring",
    "explanation": {
      "intro": "@Value is used in Spring to inject values into fields, method parameters, or constructor arguments from property files, system properties, or expressions.",
      "points": [
        "Injects configuration values from application.properties or application.yml.",
        "Can also inject default values if the property is missing.",
        "Supports Spring Expression Language (SpEL) for dynamic expressions."
      ],
      "code": "@Component\npublic class AppConfig {\n    @Value(\"${app.name}\")\n    private String appName;\n\n    public void printAppName() {\n        System.out.println(\"Application Name: \" + appName);\n    }\n}",
      "diagram": "/diagrams/spring/spring_value_injection.md"
    }
  },
  {
    "id": "94",
    "question": "What is Spring Boot Actuator?",
    "options": [
      "A monitoring and management tool for Spring Boot applications",
      "A logging library",
      "A deployment tool",
      "A security module"
    ],
    "answer": "A monitoring and management tool for Spring Boot applications",
    "isObjective": true,
    "type": "MCQ",
    "askedBy": [],
    "technology": "Spring Boot",
    "explanation": {
      "intro": "Spring Boot Actuator provides production-ready features to help monitor and manage your application.",
      "points": [
        "Exposes endpoints to check application health, metrics, and environment properties.",
        "Supports custom endpoints and integrates with monitoring tools like Prometheus and Grafana.",
        "Helps in auditing, metrics, and application tracing."
      ],
      "code": "dependencies {\n    implementation 'org.springframework.boot:spring-boot-starter-actuator'\n}\n\n# Example: Enable endpoints in application.properties\nmanagement.endpoints.web.exposure.include=health,info,metrics",
      "diagram": "/diagrams/spring/spring_boot_actuator.md"
    }
  },
  {
    "id": "95",
    "question": "Which embedded server is the default in Spring Boot?",
    "options": ["Tomcat", "Jetty", "Undertow", "WebLogic"],
    "answer": "Tomcat",
    "isObjective": true,
    "type": "MCQ",
    "askedBy": [],
    "technology": "Spring Boot",
    "explanation": {
      "intro": "Spring Boot comes with an embedded server to run web applications without external deployment.",
      "points": [
        "Tomcat is the default embedded servlet container.",
        "Other options like Jetty and Undertow can be used by excluding Tomcat and adding respective dependencies.",
        "Embedded servers simplify deployment by packaging the server with the application."
      ],
      "code": "# Example: Exclude Tomcat and use Jetty\ndependencies {\n    implementation 'org.springframework.boot:spring-boot-starter-web'\n    implementation 'org.springframework.boot:spring-boot-starter-jetty'\n    // Exclude Tomcat\n    implementation('org.springframework.boot:spring-boot-starter-web') {\n        exclude group: 'org.springframework.boot', module: 'spring-boot-starter-tomcat'\n    }\n}",
      "diagram": "/diagrams/spring/spring_boot_embedded_server.md"
    }
  },
  {
    "id": "96",
    "question": "What is the difference between @Controller and @RestController?",
    "options": [
      "@Controller returns views, @RestController returns JSON/XML",
      "They are exactly the same",
      "@Controller is only for database access",
      "@RestController can only be used with WebFlux"
    ],
    "answer": "@Controller returns views, @RestController returns JSON/XML",
    "isObjective": true,
    "type": "MCQ",
    "askedBy": [],
    "technology": "Spring Boot",
    "explanation": {
      "intro": "Spring MVC provides two main annotations for defining controllers in web applications.",
      "points": [
        "@Controller is used to define a standard MVC controller which returns view names resolved by a view resolver.",
        "@RestController is a specialization of @Controller that combines @Controller and @ResponseBody, returning JSON or XML directly.",
        "Use @RestController for REST APIs and @Controller when serving HTML views or JSP pages."
      ],
      "code": "// Example usage\n@Controller\npublic class MyController {\n    @GetMapping(\"/home\")\n    public String homePage() {\n        return \"home\"; // returns view named 'home'\n    }\n}\n\n@RestController\npublic class MyRestController {\n    @GetMapping(\"/api/data\")\n    public MyData getData() {\n        return new MyData(\"example\"); // returns JSON\n    }\n}",
      "diagram": "/diagrams/spring/controller_vs_restcontroller.md"
    }
  },
  {
    "id": "97",
    "question": "What is Spring Framework?",
    "options": [
      "A JavaScript library",
      "A Java framework for enterprise applications",
      "A database",
      "A testing tool"
    ],
    "answer": "A Java framework for enterprise applications",
    "isObjective": true,
    "type": "MCQ",
    "askedBy": [],
    "technology": "Spring",
    "explanation": {
      "intro": "Spring Framework is a comprehensive programming and configuration model for modern Java-based enterprise applications.",
      "points": [
        "Provides dependency injection (DI) to manage object creation and dependencies.",
        "Supports aspect-oriented programming (AOP) to separate cross-cutting concerns.",
        "Offers modules for data access, transaction management, web MVC, security, and more.",
        "Lightweight and promotes testable, maintainable code."
      ],
      "code": "// Example: Defining a bean in Spring\n@Component\npublic class MyService {\n    public void perform() {\n        System.out.println(\"Service executing\");\n    }\n}\n\n@Autowired\nprivate MyService myService;",
      "diagram": "/diagrams/spring/spring_framework_overview.md"
    }
  },
  {
    "id": "98",
    "question": "Which annotation is used to define a Spring Boot application?",
    "options": ["@Configuration", "@Component", "@SpringBootApplication", "@Service"],
    "answer": "@SpringBootApplication",
    "isObjective": true,
    "type": "MCQ",
    "askedBy": [],
    "technology": "Spring Boot",
    "explanation": {
      "intro": "@SpringBootApplication is a convenience annotation that combines @Configuration, @EnableAutoConfiguration, and @ComponentScan.",
      "points": [
        "Marks the main class of a Spring Boot application.",
        "Enables auto-configuration of Spring context based on dependencies.",
        "Scans for Spring components in the package and sub-packages."
      ],
      "code": "// Example:\n@SpringBootApplication\npublic class MyApp {\n    public static void main(String[] args) {\n        SpringApplication.run(MyApp.class, args);\n    }\n}",
      "diagram": "/diagrams/spring/springboot_application.md"
    }
  },
  {
    "id": "99",
    "question": "What is the default scope of a Spring bean?",
    "options": ["prototype", "singleton", "request", "session"],
    "answer": "singleton",
    "isObjective": true,
    "type": "MCQ",
    "askedBy": [],
    "technology": "Spring",
    "explanation": {
      "intro": "In Spring, beans are singleton by default, meaning only one instance is created per Spring container.",
      "points": [
        "Singleton beans are created once and shared across the application context.",
        "Prototype beans are created every time they are requested.",
        "Other scopes like 'request' and 'session' apply in web-aware Spring contexts."
      ],
      "code": "// Example:\n@Component\npublic class MyService {\n    // This bean is singleton by default\n}",
      "diagram": "/diagrams/spring/spring_bean_scope.md"
    }
  },
  {
    "id": "100",
    "question": "Which annotation is used for automatic dependency injection in Spring?",
    "options": ["@Bean", "@Autowired", "@Inject", "@Configuration"],
    "answer": "@Autowired",
    "isObjective": true,
    "type": "MCQ",
    "askedBy": [],
    "technology": "Spring",
    "explanation": {
      "intro": "@Autowired is used by Spring to automatically wire beans by type.",
      "points": [
        "It can be applied on fields, constructors, or setter methods.",
        "Spring resolves the dependency automatically from the application context.",
        "It helps reduce manual bean wiring and promotes loose coupling."
      ],
      "code": "// Example:\n@Component\npublic class MyService {\n    @Autowired\n    private MyRepository repository;\n}",
      "diagram": "/diagrams/spring/spring_autowired.md"
    }
  },
  {
    "id": "101",
    "question": "What is Spring Boot Starter?",
    "options": ["A test framework", "A collection of dependencies for rapid development", "A logging tool", "An IDE plugin"],
    "answer": "A collection of dependencies for rapid development",
    "isObjective": true,
    "type": "MCQ",
    "askedBy": [],
    "technology": "Spring Boot",
    "explanation": {
      "intro": "Spring Boot Starters are pre-defined dependency descriptors that simplify Maven or Gradle configuration.",
      "points": [
        "They aggregate common libraries for specific tasks (e.g., web, data, security).",
        "They help start a project quickly without manually adding individual dependencies.",
        "Examples include spring-boot-starter-web, spring-boot-starter-data-jpa, spring-boot-starter-security."
      ],
      "code": "// Example in Maven pom.xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-web</artifactId>\n</dependency>",
      "diagram": "/diagrams/spring/spring_boot_starter1.md"
    }
  },
  {
    "id": "102",
    "question": "Which annotation is used to mark a class as a configuration class?",
    "options": ["@Configuration", "@Component", "@RestController", "@Bean"],
    "answer": "@Configuration",
    "isObjective": true,
    "type": "MCQ",
    "askedBy": [],
    "technology": "Spring",
    "explanation": {
      "intro": "The @Configuration annotation indicates that the class contains Spring bean definitions.",
      "points": [
        "It is processed by the Spring container to generate bean definitions and service requests.",
        "Used in combination with @Bean methods to define beans programmatically.",
        "Helps in Java-based configuration instead of XML configuration."
      ],
      "code": "import org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\npublic class AppConfig {\n    @Bean\n    public MyService myService() {\n        return new MyService();\n    }\n}",
      "diagram": "/diagrams/spring/spring_configuration.md"
    }
  },
  {
    "id": "103",
    "question": "What is Spring Boot Actuator?",
    "options": [
      "A monitoring and management tool for Spring Boot applications",
      "A logging library",
      "A deployment tool",
      "A security module"
    ],
    "answer": "A monitoring and management tool for Spring Boot applications",
    "isObjective": true,
    "type": "MCQ",
    "askedBy": [],
    "technology": "Spring Boot",
    "explanation": {
      "intro": "Spring Boot Actuator provides production-ready features to monitor and manage Spring Boot applications.",
      "points": [
        "Exposes endpoints like /actuator/health, /actuator/metrics, /actuator/env.",
        "Helps in application monitoring, metrics collection, and environment inspection.",
        "Integrates with external monitoring systems like Prometheus and Grafana."
      ],
      "code": "dependencies {\n    implementation 'org.springframework.boot:spring-boot-starter-actuator'\n}\n\n# Example usage in application.properties\nmanagement.endpoints.web.exposure.include=health,info,metrics",
      "diagram": "/diagrams/spring/spring_boot_actuator.md"
    }
  },
  {
    "id": "108",
    "type": "Interview",
    "technology": "Spring Boot",
    "question": "How does Spring Boot simplify dependency management?",
    "answer": "It uses starters (predefined dependency sets) and auto-configuration to reduce boilerplate setup.",
    "isObjective": false,
    "options": [],
    "askedBy": [],
    "explanation": {
      "intro": "Spring Boot provides starters and auto-configuration to simplify project setup and dependency management.",
      "points": [
        "Starters are pre-packaged dependency sets like spring-boot-starter-web, spring-boot-starter-data-jpa.",
        "Auto-configuration automatically sets up beans and configurations based on the classpath.",
        "Reduces manual configuration and avoids version conflicts."
      ],
      "code": "# Example: Adding Web Starter in build.gradle\nimplementation 'org.springframework.boot:spring-boot-starter-web'\n\n# Auto-configures DispatcherServlet, REST controllers, JSON converters, etc.",
      "diagram": "/diagrams/spring/spring_boot_dependency_management.md"
    }
  },
  {
    "id": "109",
    "type": "Interview",
    "technology": "Spring",
    "question": "What is Dependency Injection and why is it important in Spring?",
    "answer": "Dependency Injection is a design pattern where dependencies are injected by the container rather than created manually. It promotes loose coupling and testability.",
    "isObjective": false,
    "options": [],
    "askedBy": [],
    "explanation": {
      "intro": "Dependency Injection (DI) allows Spring to manage object creation and wiring, reducing tight coupling.",
      "points": [
        "Promotes loose coupling between classes.",
        "Improves code testability by allowing mock injections.",
        "Reduces boilerplate code and simplifies object management."
      ],
      "code": "// Example: Constructor Injection in Spring\n@Component\nclass Engine {}\n\n@Component\nclass Car {\n    private final Engine engine;\n\n    @Autowired\n    public Car(Engine engine) {\n        this.engine = engine;\n    }\n}",
      "diagram": "/diagrams/spring/dependency_injection.md"
    }
  },
  {
    "id": "110",
    "type": "Interview",
    "technology": "Spring",
    "question": "What are Spring Profiles used for?",
    "answer": "Profiles allow you to define different configurations for different environments (e.g., dev, test, prod).",
    "isObjective": false,
    "options": [],
    "askedBy": [],
    "explanation": {
      "intro": "Spring Profiles help manage environment-specific configurations in a clean and organized way.",
      "points": [
        "Enable switching between environments without changing code.",
        "Activate a profile via `application.properties` or programmatically.",
        "Use `@Profile` annotation to mark beans for specific profiles."
      ],
      "code": "// Example: Defining a bean for 'dev' profile\n@Configuration\n@Profile(\"dev\")\nclass DevDataSourceConfig {\n    @Bean\n    public DataSource dataSource() {\n        return new HikariDataSource();\n    }\n}",
      "diagram": "/diagrams/spring/spring_profiles.md"
    }
  },
  {
    "id": "111",
    "type": "Interview",
    "technology": "Spring Boot",
    "question": "How does Spring Boot handle database configuration?",
    "answer": "Spring Boot auto-configures DataSource and JPA repositories if required properties are provided in application.properties.",
    "isObjective": false,
    "options": [],
    "askedBy": [],
    "explanation": {
      "intro": "Spring Boot simplifies database setup by auto-configuring beans and repositories based on dependencies and properties.",
      "points": [
        "Detects database driver from classpath.",
        "Auto-configures `DataSource` bean if `spring.datasource.*` properties are set.",
        "Automatically sets up JPA repositories if Spring Data JPA is on classpath.",
        "Reduces boilerplate XML or Java configuration."
      ],
      "code": "// application.properties example\nspring.datasource.url=jdbc:mysql://localhost:3306/mydb\nspring.datasource.username=root\nspring.datasource.password=secret\nspring.jpa.hibernate.ddl-auto=update\n\n// No explicit DataSource bean required; Spring Boot creates it automatically",
      "diagram": "/diagrams/spring/spring_boot_database.md"
    }
  },
  {
    "id": "112",
    "type": "Interview",
    "technology": "Spring",
    "question": "What is the difference between @Component, @Service, and @Repository?",
    "answer": "@Component is a generic stereotype, @Service is for service layer beans, and @Repository is for persistence layer beans (with additional exception translation).",
    "isObjective": false,
    "options": [],
    "askedBy": [],
    "explanation": {
      "intro": "Spring provides several stereotype annotations to define beans semantically, making code more readable and maintainable.",
      "points": [
        "@Component: Generic annotation to register any bean in Spring context.",
        "@Service: Specialization of @Component for service layer logic.",
        "@Repository: Specialization of @Component for persistence layer; enables exception translation from database exceptions to Spring DataAccessException."
      ],
      "code": "```java\n@Component\npublic class MyComponent {}\n\n@Service\npublic class MyService {}\n\n@Repository\npublic class MyRepository {}\n```",
      "diagram": "/diagrams/spring/spring_component_hierarchy.md"
    }
  },
  {
    "id": "113",
    "type": "Interview",
    "technology": "Spring Boot",
    "question": "How does Spring Boot enable microservices development?",
    "answer": "Spring Boot provides embedded servers, auto-configuration, easy integration with Spring Cloud, and REST support, making microservices easier to build and deploy.",
    "isObjective": false,
    "options": [],
    "askedBy": [],
    "explanation": {
      "intro": "Spring Boot simplifies microservices development by reducing boilerplate and providing built-in infrastructure support.",
      "points": [
        "Embedded servers (Tomcat/Jetty/Undertow) remove the need for external server setup.",
        "Auto-configuration detects dependencies and configures beans automatically.",
        "Integration with Spring Cloud provides features like service discovery, config management, and circuit breakers.",
        "REST controllers and easy JSON serialization make exposing endpoints straightforward."
      ],
      "code": "```java\n@SpringBootApplication\npublic class UserServiceApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(UserServiceApplication.class, args);\n    }\n}\n\n@RestController\n@RequestMapping(\"/users\")\npublic class UserController {\n    @GetMapping\n    public List<User> getAllUsers() {\n        return userService.findAll();\n    }\n}\n```",
      "diagram": "/diagrams/spring/springboot_microservices.md"
    }
  },
  {
    "id": "114",
    "type": "Interview",
    "technology": "Spring",
    "question": "What is the role of Spring Security?",
    "answer": "Spring Security provides authentication, authorization, and protection against common attacks like CSRF, session fixation, and clickjacking.",
    "isObjective": false,
    "options": [],
    "askedBy": [],
    "explanation": {
      "intro": "Spring Security is a framework that secures Java applications by managing user access and protecting resources.",
      "points": [
        "Authentication: Verify identity of users (login).",
        "Authorization: Control access to resources based on roles or permissions.",
        "CSRF Protection: Prevent cross-site request forgery attacks.",
        "Session Management: Protect against session fixation and hijacking.",
        "Security Headers: Prevent clickjacking and other web attacks."
      ],
      "code": "```java\n@Configuration\n@EnableWebSecurity\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\n\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        http\n            .authorizeRequests()\n                .antMatchers(\"/public/**\").permitAll()\n                .anyRequest().authenticated()\n            .and()\n            .formLogin()\n            .and()\n            .csrf();\n    }\n}\n```",
      "diagram": "/diagrams/spring/spring_security_flow.md"
    }
  },
  {
    "id": "115",
    "type": "Interview",
    "technology": "Spring Boot",
    "question": "What are some advantages of using Spring Boot over traditional Spring?",
    "answer": "Auto-configuration, embedded servers, production-ready features (Actuator), reduced XML configuration, and opinionated defaults.",
    "isObjective": false,
    "options": [],
    "askedBy": [],
    "explanation": {
      "intro": "Spring Boot simplifies Spring application development by providing sensible defaults and reducing boilerplate.",
      "points": [
        "Auto-Configuration: Automatically configures beans based on dependencies.",
        "Embedded Servers: Comes with Tomcat, Jetty, or Undertow, so no need for external deployment.",
        "Production-Ready Features: Actuator provides metrics, health checks, and monitoring.",
        "Reduced XML Configuration: Prefer Java-based configuration over verbose XML.",
        "Opinionated Defaults: Provides default configurations that follow best practices, speeding up development."
      ],
      "code": "```java\n@SpringBootApplication\npublic class MyApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(MyApplication.class, args);\n    }\n}\n```",
      "diagram": "/diagrams/spring/spring_boot_advantages.md"
  }
  },
  {
    "id": "116",
    "type": "Interview",
    "technology": "Spring Boot",
    "question": "How would you secure a REST API in Spring Boot?",
    "answer": "By using Spring Security with JWT, OAuth2, or Basic Authentication depending on requirements.",
    "isObjective": false,
    "options": [],
    "askedBy": [],
    "explanation": {
      "intro": "Spring Boot applications can be secured using Spring Security which provides authentication and authorization mechanisms.",
      "points": [
        "Use Spring Security dependency in the project.",
        "Configure authentication methods: Basic Auth, JWT, OAuth2.",
        "Protect endpoints using annotations like @PreAuthorize or HttpSecurity configuration.",
        "Enable HTTPS to secure data in transit.",
        "Implement role-based access control for fine-grained security."
      ],
      "code": "```java\n@Configuration\n@EnableWebSecurity\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        http\n          .csrf().disable()\n          .authorizeRequests()\n          .antMatchers(\"/public/**\").permitAll()\n          .anyRequest().authenticated()\n          .and()\n          .httpBasic();\n    }\n}\n```",
      "diagram": "/diagrams/spring/spring_security_rest_api.md"
    }
  }
]